---
phase: 02-core-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/orchestration/__init__.py
  - src/orchestration/state_machine.py
  - tests/orchestration/__init__.py
  - tests/orchestration/test_state_machine.py
autonomous: true

must_haves:
  truths:
    - "python-statemachine and pybreaker packages are installed"
    - "TaskStateMachine transitions pending -> assigned -> in_progress -> completed"
    - "TaskStateMachine transitions in_progress -> failed and in_progress -> escalated"
    - "TaskStateMachine prevents invalid transitions (e.g., pending -> completed)"
    - "All state machine tests pass"
  artifacts:
    - path: "src/orchestration/state_machine.py"
      provides: "Declarative task state machine"
      contains: "class TaskStateMachine"
    - path: "pyproject.toml"
      provides: "Phase 2 dependencies"
      contains: "python-statemachine"
  key_links:
    - from: "src/orchestration/state_machine.py"
      to: "statemachine"
      via: "import"
      pattern: "from statemachine import"
    - from: "src/orchestration/state_machine.py"
      to: "src/models/task.py"
      via: "import"
      pattern: "from src.models.task import TaskStatus"
---

<objective>
Install Phase 2 dependencies and implement the task state machine for orchestration.

Purpose: Provide declarative state machine that enforces valid task transitions, preventing invalid state changes and providing hooks for side effects on transitions.

Output: Working TaskStateMachine class that transitions through all valid states (pending -> assigned -> in_progress -> completed/failed/escalated) with comprehensive test coverage.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-framework/02-RESEARCH.md
@src/models/task.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Phase 2 dependencies</name>
  <files>pyproject.toml</files>
  <action>
    Add Phase 2 dependencies:
    ```bash
    uv add python-statemachine pybreaker pydantic-yaml ruamel.yaml voyageai
    ```

    Dependencies purpose:
    - python-statemachine: Declarative task state machine (ORCH-01)
    - pybreaker: Circuit breaker with Redis storage (ORCH-03, 04, 05)
    - pydantic-yaml: Type-safe YAML parsing for skills (SKILL-01)
    - ruamel.yaml: YAML parsing backend that preserves structure
    - voyageai: Embeddings for semantic search (SEARCH-01)
  </action>
  <verify>
    - `uv sync` completes without error
    - `python -c "import statemachine; import pybreaker; import voyageai"` succeeds
  </verify>
  <done>All Phase 2 Python dependencies are installed</done>
</task>

<task type="auto">
  <name>Task 2: Create orchestration module with TaskStateMachine</name>
  <files>src/orchestration/__init__.py, src/orchestration/state_machine.py</files>
  <action>
    1. Create src/orchestration/__init__.py (empty module init)

    2. Create src/orchestration/state_machine.py with:

    ```python
    """Task state machine for orchestration.

    Provides declarative state transitions for tasks with async callbacks
    for side effects (database updates, logging, metrics).
    """

    from datetime import datetime
    from typing import TYPE_CHECKING

    import structlog
    from statemachine import State, StateMachine
    from statemachine.exceptions import TransitionNotAllowed

    from src.models.task import TaskStatus

    if TYPE_CHECKING:
        from sqlalchemy.ext.asyncio import AsyncSession
        from src.models.task import Task

    logger = structlog.get_logger()


    class TaskStateMachine(StateMachine):
        """State machine for task lifecycle management.

        States match TaskStatus enum from models:
        - pending: Task created, awaiting assignment
        - assigned: Task assigned to an agent
        - in_progress: Agent actively working on task
        - completed: Task finished successfully (final)
        - failed: Task failed after max retries (final)
        - escalated: Task requires human intervention (final)

        Transitions:
        - assign: pending -> assigned
        - start: assigned -> in_progress
        - complete: in_progress -> completed
        - fail: in_progress/assigned -> failed
        - escalate: in_progress/assigned -> escalated
        - retry: failed -> pending (allows retry after failure)
        """

        # States (match TaskStatus enum values)
        pending = State(initial=True, value=TaskStatus.PENDING)
        assigned = State(value=TaskStatus.ASSIGNED)
        in_progress = State(value=TaskStatus.IN_PROGRESS)
        completed = State(final=True, value=TaskStatus.COMPLETED)
        failed = State(final=True, value=TaskStatus.FAILED)
        escalated = State(final=True, value=TaskStatus.ESCALATED)

        # Transitions
        assign = pending.to(assigned)
        start = assigned.to(in_progress)
        complete = in_progress.to(completed)
        fail = in_progress.to(failed) | assigned.to(failed)
        escalate = in_progress.to(escalated) | assigned.to(escalated)
        retry = failed.to(pending)

        def __init__(
            self,
            task: "Task",
            session: "AsyncSession | None" = None,
        ):
            """Initialize state machine for a task.

            Args:
                task: Task model instance to manage
                session: Optional SQLAlchemy session for persistence
            """
            self.task = task
            self.session = session
            # Initialize from task's current status
            super().__init__()

        @property
        def current_state_value(self) -> TaskStatus:
            """Get current state as TaskStatus enum."""
            return self.current_state.value

        def _get_initial_state(self) -> State:
            """Determine initial state from task's current status."""
            status_to_state = {
                TaskStatus.PENDING: self.pending,
                TaskStatus.ASSIGNED: self.assigned,
                TaskStatus.IN_PROGRESS: self.in_progress,
                TaskStatus.COMPLETED: self.completed,
                TaskStatus.FAILED: self.failed,
                TaskStatus.ESCALATED: self.escalated,
            }
            return status_to_state.get(self.task.status, self.pending)

        # Transition callbacks
        def on_assign(self, agent: str) -> None:
            """Called when task is assigned to an agent.

            Args:
                agent: Name/identifier of the assigned agent
            """
            self.task.assigned_agent = agent
            self.task.status = TaskStatus.ASSIGNED
            logger.info(
                "task_assigned",
                task_id=self.task.id,
                agent=agent,
            )

        def on_start(self) -> None:
            """Called when agent starts working on task."""
            self.task.status = TaskStatus.IN_PROGRESS
            logger.info(
                "task_started",
                task_id=self.task.id,
                agent=self.task.assigned_agent,
            )

        def on_complete(self) -> None:
            """Called when task completes successfully."""
            self.task.status = TaskStatus.COMPLETED
            self.task.completed_at = datetime.utcnow()
            logger.info(
                "task_completed",
                task_id=self.task.id,
                agent=self.task.assigned_agent,
            )

        def on_fail(self, reason: str = "") -> None:
            """Called when task fails.

            Args:
                reason: Description of failure
            """
            self.task.status = TaskStatus.FAILED
            logger.warning(
                "task_failed",
                task_id=self.task.id,
                agent=self.task.assigned_agent,
                reason=reason,
            )

        def on_escalate(self, reason: str = "") -> None:
            """Called when task is escalated to human.

            Args:
                reason: Description of why escalation needed
            """
            self.task.status = TaskStatus.ESCALATED
            logger.warning(
                "task_escalated",
                task_id=self.task.id,
                agent=self.task.assigned_agent,
                reason=reason,
            )

        def on_retry(self) -> None:
            """Called when retrying a failed task."""
            self.task.status = TaskStatus.PENDING
            self.task.assigned_agent = None
            self.task.completed_at = None
            logger.info(
                "task_retry",
                task_id=self.task.id,
            )


    def create_state_machine(
        task: "Task",
        session: "AsyncSession | None" = None,
    ) -> TaskStateMachine:
        """Factory function to create state machine for a task.

        Args:
            task: Task model instance
            session: Optional SQLAlchemy session

        Returns:
            TaskStateMachine initialized from task's current state
        """
        return TaskStateMachine(task=task, session=session)


    __all__ = [
        "TaskStateMachine",
        "TransitionNotAllowed",
        "create_state_machine",
    ]
    ```

    Note: The state machine synchronously updates the task model. The caller is responsible for committing via the session. This keeps the state machine pure and testable.
  </action>
  <verify>
    - `python -c "from src.orchestration.state_machine import TaskStateMachine"` succeeds
    - Module structure exists: src/orchestration/__init__.py, src/orchestration/state_machine.py
  </verify>
  <done>TaskStateMachine class exists with all states and transitions</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive state machine tests</name>
  <files>tests/orchestration/__init__.py, tests/orchestration/test_state_machine.py</files>
  <action>
    1. Create tests/orchestration/__init__.py (empty)

    2. Create tests/orchestration/test_state_machine.py:

    ```python
    """Tests for task state machine."""

    import pytest
    from statemachine.exceptions import TransitionNotAllowed

    from src.models.task import Task, TaskStatus
    from src.orchestration.state_machine import (
        TaskStateMachine,
        create_state_machine,
    )


    class TestTaskStateMachine:
        """Tests for TaskStateMachine transitions."""

        def _create_task(self, status: TaskStatus = TaskStatus.PENDING) -> Task:
            """Create a mock task for testing."""
            task = Task(
                id=1,
                client_id=1,
                task_type="personal_tax",
                status=status,
            )
            return task

        def test_initial_state_from_pending_task(self) -> None:
            """State machine starts in pending state for pending task."""
            task = self._create_task(TaskStatus.PENDING)
            sm = TaskStateMachine(task=task)

            assert sm.current_state == sm.pending
            assert sm.current_state_value == TaskStatus.PENDING

        def test_initial_state_from_in_progress_task(self) -> None:
            """State machine starts in correct state for non-pending task."""
            task = self._create_task(TaskStatus.IN_PROGRESS)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            assert sm.current_state == sm.in_progress
            assert sm.current_state_value == TaskStatus.IN_PROGRESS

        def test_assign_transition(self) -> None:
            """Transition from pending to assigned."""
            task = self._create_task()
            sm = TaskStateMachine(task=task)

            sm.assign(agent="personal_tax_agent")

            assert sm.current_state == sm.assigned
            assert task.status == TaskStatus.ASSIGNED
            assert task.assigned_agent == "personal_tax_agent"

        def test_start_transition(self) -> None:
            """Transition from assigned to in_progress."""
            task = self._create_task(TaskStatus.ASSIGNED)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.start()

            assert sm.current_state == sm.in_progress
            assert task.status == TaskStatus.IN_PROGRESS

        def test_complete_transition(self) -> None:
            """Transition from in_progress to completed."""
            task = self._create_task(TaskStatus.IN_PROGRESS)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.complete()

            assert sm.current_state == sm.completed
            assert task.status == TaskStatus.COMPLETED
            assert task.completed_at is not None

        def test_fail_from_in_progress(self) -> None:
            """Transition from in_progress to failed."""
            task = self._create_task(TaskStatus.IN_PROGRESS)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.fail(reason="LLM API error")

            assert sm.current_state == sm.failed
            assert task.status == TaskStatus.FAILED

        def test_fail_from_assigned(self) -> None:
            """Transition from assigned to failed."""
            task = self._create_task(TaskStatus.ASSIGNED)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.fail(reason="Agent unavailable")

            assert sm.current_state == sm.failed
            assert task.status == TaskStatus.FAILED

        def test_escalate_from_in_progress(self) -> None:
            """Transition from in_progress to escalated."""
            task = self._create_task(TaskStatus.IN_PROGRESS)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.escalate(reason="Missing W-2 document")

            assert sm.current_state == sm.escalated
            assert task.status == TaskStatus.ESCALATED

        def test_escalate_from_assigned(self) -> None:
            """Transition from assigned to escalated."""
            task = self._create_task(TaskStatus.ASSIGNED)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.escalate(reason="Client data inconsistency")

            assert sm.current_state == sm.escalated
            assert task.status == TaskStatus.ESCALATED

        def test_retry_from_failed(self) -> None:
            """Transition from failed back to pending for retry."""
            task = self._create_task(TaskStatus.FAILED)
            task.assigned_agent = "personal_tax_agent"
            sm = TaskStateMachine(task=task)

            sm.retry()

            assert sm.current_state == sm.pending
            assert task.status == TaskStatus.PENDING
            assert task.assigned_agent is None
            assert task.completed_at is None

        def test_invalid_transition_pending_to_completed(self) -> None:
            """Cannot transition directly from pending to completed."""
            task = self._create_task(TaskStatus.PENDING)
            sm = TaskStateMachine(task=task)

            with pytest.raises(TransitionNotAllowed):
                sm.complete()

        def test_invalid_transition_pending_to_in_progress(self) -> None:
            """Cannot transition directly from pending to in_progress."""
            task = self._create_task(TaskStatus.PENDING)
            sm = TaskStateMachine(task=task)

            with pytest.raises(TransitionNotAllowed):
                sm.start()

        def test_invalid_transition_from_completed(self) -> None:
            """Cannot transition from completed (final state)."""
            task = self._create_task(TaskStatus.COMPLETED)
            sm = TaskStateMachine(task=task)

            with pytest.raises(TransitionNotAllowed):
                sm.retry()

        def test_invalid_transition_from_escalated(self) -> None:
            """Cannot transition from escalated (final state)."""
            task = self._create_task(TaskStatus.ESCALATED)
            sm = TaskStateMachine(task=task)

            with pytest.raises(TransitionNotAllowed):
                sm.retry()

        def test_full_happy_path(self) -> None:
            """Test complete successful workflow."""
            task = self._create_task()
            sm = TaskStateMachine(task=task)

            # Full workflow: pending -> assigned -> in_progress -> completed
            sm.assign(agent="personal_tax_agent")
            sm.start()
            sm.complete()

            assert task.status == TaskStatus.COMPLETED
            assert task.assigned_agent == "personal_tax_agent"
            assert task.completed_at is not None

        def test_fail_and_retry_path(self) -> None:
            """Test failure with retry workflow."""
            task = self._create_task()
            sm = TaskStateMachine(task=task)

            # Workflow: pending -> assigned -> in_progress -> failed -> pending
            sm.assign(agent="personal_tax_agent")
            sm.start()
            sm.fail(reason="Temporary error")
            sm.retry()

            assert task.status == TaskStatus.PENDING
            assert task.assigned_agent is None

        def test_create_state_machine_factory(self) -> None:
            """Test factory function creates correct state machine."""
            task = self._create_task(TaskStatus.ASSIGNED)
            task.assigned_agent = "test_agent"

            sm = create_state_machine(task=task)

            assert isinstance(sm, TaskStateMachine)
            assert sm.current_state == sm.assigned
            assert sm.task is task
    ```
  </action>
  <verify>
    - `pytest tests/orchestration/test_state_machine.py -v` passes all tests
    - All transition paths covered (happy path, fail path, retry path)
    - Invalid transitions raise TransitionNotAllowed
  </verify>
  <done>State machine tests pass, covering all valid and invalid transitions</done>
</task>

</tasks>

<verification>
1. `uv sync` installs all Phase 2 dependencies
2. `python -c "from src.orchestration.state_machine import TaskStateMachine, create_state_machine"` imports successfully
3. `pytest tests/orchestration/test_state_machine.py -v` passes all tests
4. State machine prevents invalid transitions (tested by TransitionNotAllowed exceptions)
</verification>

<success_criteria>
- All Phase 2 dependencies installed (python-statemachine, pybreaker, pydantic-yaml, ruamel.yaml, voyageai)
- TaskStateMachine class implements all states and transitions
- State machine tests pass with 100% of transitions covered
- Invalid transitions raise TransitionNotAllowed exception
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-framework/02-01-SUMMARY.md`
</output>
