---
phase: 02-core-framework
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/dispatcher.py
  - tests/orchestration/test_dispatcher.py
autonomous: true

must_haves:
  truths:
    - "TaskDispatcher routes tasks to registered handlers by task_type"
    - "TaskDispatcher raises ValueError for unregistered task types"
    - "Handlers are async callables that accept a Task"
    - "All dispatcher tests pass"
  artifacts:
    - path: "src/orchestration/dispatcher.py"
      provides: "Task routing by type"
      contains: "class TaskDispatcher"
    - path: "tests/orchestration/test_dispatcher.py"
      provides: "Dispatcher test coverage"
      contains: "test_dispatch_to_registered_handler"
  key_links:
    - from: "src/orchestration/dispatcher.py"
      to: "src/models/task.py"
      via: "import"
      pattern: "from src.models.task import Task"
---

<objective>
Implement task dispatcher that routes tasks to agent handlers by task_type.

Purpose: Enable task routing so different task types (personal_tax, business_tax, bookkeeping) are handled by their specialized agents.

Output: Working TaskDispatcher class that routes tasks to registered handlers with comprehensive test coverage.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-framework/02-RESEARCH.md
@src/models/task.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskDispatcher for routing tasks to handlers</name>
  <files>src/orchestration/dispatcher.py</files>
  <action>
    Create src/orchestration/dispatcher.py:

    ```python
    """Task dispatcher for routing tasks to agent handlers.

    Provides task_type-based routing to specialized agent handlers.
    Each task type (personal_tax, business_tax, bookkeeping) is handled
    by a registered async handler function.
    """

    from typing import TYPE_CHECKING, Awaitable, Callable

    import structlog

    if TYPE_CHECKING:
        from src.models.task import Task

    logger = structlog.get_logger()

    # Type alias for agent handlers
    AgentHandler = Callable[["Task"], Awaitable[None]]


    class TaskDispatcher:
        """Routes tasks to agent handlers by task_type.

        Usage:
            dispatcher = TaskDispatcher()
            dispatcher.register("personal_tax", personal_tax_agent.handle)
            dispatcher.register("business_tax", business_tax_agent.handle)

            # Later, dispatch a task
            await dispatcher.dispatch(task)  # Routes to correct handler

        Thread Safety:
            Handler registration is not thread-safe. Register all handlers
            at application startup before processing tasks.
        """

        def __init__(self) -> None:
            """Initialize dispatcher with empty handler registry."""
            self._handlers: dict[str, AgentHandler] = {}

        def register(self, task_type: str, handler: AgentHandler) -> None:
            """Register a handler for a task type.

            Args:
                task_type: Task type identifier (e.g., "personal_tax")
                handler: Async function that processes tasks of this type

            Raises:
                ValueError: If task_type is empty
            """
            if not task_type:
                raise ValueError("task_type cannot be empty")

            if task_type in self._handlers:
                logger.warning(
                    "handler_replaced",
                    task_type=task_type,
                    message="Replacing existing handler for task type",
                )

            self._handlers[task_type] = handler
            logger.info(
                "handler_registered",
                task_type=task_type,
            )

        def unregister(self, task_type: str) -> bool:
            """Unregister a handler for a task type.

            Args:
                task_type: Task type to unregister

            Returns:
                True if handler was removed, False if not found
            """
            if task_type in self._handlers:
                del self._handlers[task_type]
                logger.info(
                    "handler_unregistered",
                    task_type=task_type,
                )
                return True
            return False

        def is_registered(self, task_type: str) -> bool:
            """Check if a handler is registered for a task type.

            Args:
                task_type: Task type to check

            Returns:
                True if handler is registered
            """
            return task_type in self._handlers

        @property
        def registered_types(self) -> list[str]:
            """Get list of registered task types."""
            return list(self._handlers.keys())

        async def dispatch(self, task: "Task") -> None:
            """Dispatch a task to its registered handler.

            Args:
                task: Task to dispatch

            Raises:
                ValueError: If no handler registered for task's task_type
            """
            handler = self._handlers.get(task.task_type)

            if handler is None:
                logger.error(
                    "dispatch_failed",
                    task_id=task.id,
                    task_type=task.task_type,
                    registered_types=self.registered_types,
                    message="No handler registered for task type",
                )
                raise ValueError(
                    f"No handler registered for task type: {task.task_type}"
                )

            logger.info(
                "task_dispatched",
                task_id=task.id,
                task_type=task.task_type,
            )

            await handler(task)

            logger.info(
                "task_handler_completed",
                task_id=task.id,
                task_type=task.task_type,
            )


    # Module-level singleton for convenience (optional usage pattern)
    _default_dispatcher: TaskDispatcher | None = None


    def get_dispatcher() -> TaskDispatcher:
        """Get or create the default task dispatcher singleton.

        Returns:
            The default TaskDispatcher instance
        """
        global _default_dispatcher
        if _default_dispatcher is None:
            _default_dispatcher = TaskDispatcher()
        return _default_dispatcher


    def reset_dispatcher() -> None:
        """Reset the default dispatcher. Primarily for testing."""
        global _default_dispatcher
        _default_dispatcher = None


    __all__ = [
        "TaskDispatcher",
        "AgentHandler",
        "get_dispatcher",
        "reset_dispatcher",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.orchestration.dispatcher import TaskDispatcher, get_dispatcher"` succeeds
    - Module contains TaskDispatcher class with register/dispatch methods
  </verify>
  <done>TaskDispatcher class exists with registration and dispatch methods</done>
</task>

<task type="auto">
  <name>Task 2: Update orchestration __init__.py with exports</name>
  <files>src/orchestration/__init__.py</files>
  <action>
    Update src/orchestration/__init__.py to export dispatcher:

    ```python
    """Orchestration module for task management and routing.

    Provides:
    - TaskStateMachine: Declarative state machine for task lifecycle
    - TaskDispatcher: Routes tasks to agent handlers by type
    """

    from src.orchestration.dispatcher import (
        AgentHandler,
        TaskDispatcher,
        get_dispatcher,
        reset_dispatcher,
    )
    from src.orchestration.state_machine import (
        TaskStateMachine,
        TransitionNotAllowed,
        create_state_machine,
    )

    __all__ = [
        # State machine
        "TaskStateMachine",
        "TransitionNotAllowed",
        "create_state_machine",
        # Dispatcher
        "TaskDispatcher",
        "AgentHandler",
        "get_dispatcher",
        "reset_dispatcher",
    ]
    ```

    Note: If state_machine.py doesn't exist yet (from Plan 02-01), create a minimal __init__.py with just dispatcher exports:

    ```python
    """Orchestration module for task management and routing."""

    from src.orchestration.dispatcher import (
        AgentHandler,
        TaskDispatcher,
        get_dispatcher,
        reset_dispatcher,
    )

    __all__ = [
        "TaskDispatcher",
        "AgentHandler",
        "get_dispatcher",
        "reset_dispatcher",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.orchestration import TaskDispatcher"` succeeds
  </verify>
  <done>Orchestration module exports dispatcher classes</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive dispatcher tests</name>
  <files>tests/orchestration/test_dispatcher.py</files>
  <action>
    Create tests/orchestration/test_dispatcher.py:

    ```python
    """Tests for task dispatcher."""

    import pytest

    from src.models.task import Task, TaskStatus
    from src.orchestration.dispatcher import (
        TaskDispatcher,
        get_dispatcher,
        reset_dispatcher,
    )


    class TestTaskDispatcher:
        """Tests for TaskDispatcher routing."""

        def setup_method(self) -> None:
            """Reset dispatcher before each test."""
            reset_dispatcher()

        def _create_task(
            self,
            task_type: str = "personal_tax",
            status: TaskStatus = TaskStatus.PENDING,
        ) -> Task:
            """Create a mock task for testing."""
            return Task(
                id=1,
                client_id=1,
                task_type=task_type,
                status=status,
            )

        @pytest.mark.asyncio
        async def test_dispatch_to_registered_handler(self) -> None:
            """Tasks are dispatched to their registered handler."""
            dispatcher = TaskDispatcher()
            calls: list[Task] = []

            async def mock_handler(task: Task) -> None:
                calls.append(task)

            dispatcher.register("personal_tax", mock_handler)
            task = self._create_task(task_type="personal_tax")

            await dispatcher.dispatch(task)

            assert len(calls) == 1
            assert calls[0] is task

        @pytest.mark.asyncio
        async def test_dispatch_unregistered_type_raises(self) -> None:
            """Dispatching unregistered task type raises ValueError."""
            dispatcher = TaskDispatcher()
            task = self._create_task(task_type="unknown_type")

            with pytest.raises(ValueError) as exc_info:
                await dispatcher.dispatch(task)

            assert "No handler registered for task type: unknown_type" in str(
                exc_info.value
            )

        @pytest.mark.asyncio
        async def test_dispatch_multiple_types(self) -> None:
            """Different task types route to different handlers."""
            dispatcher = TaskDispatcher()
            personal_calls: list[Task] = []
            business_calls: list[Task] = []

            async def personal_handler(task: Task) -> None:
                personal_calls.append(task)

            async def business_handler(task: Task) -> None:
                business_calls.append(task)

            dispatcher.register("personal_tax", personal_handler)
            dispatcher.register("business_tax", business_handler)

            personal_task = self._create_task(task_type="personal_tax")
            business_task = self._create_task(task_type="business_tax")

            await dispatcher.dispatch(personal_task)
            await dispatcher.dispatch(business_task)

            assert len(personal_calls) == 1
            assert personal_calls[0] is personal_task
            assert len(business_calls) == 1
            assert business_calls[0] is business_task

        def test_register_empty_type_raises(self) -> None:
            """Registering empty task type raises ValueError."""
            dispatcher = TaskDispatcher()

            async def mock_handler(task: Task) -> None:
                pass

            with pytest.raises(ValueError) as exc_info:
                dispatcher.register("", mock_handler)

            assert "task_type cannot be empty" in str(exc_info.value)

        def test_register_replaces_existing_handler(self) -> None:
            """Registering same task type replaces handler."""
            dispatcher = TaskDispatcher()

            async def handler1(task: Task) -> None:
                pass

            async def handler2(task: Task) -> None:
                pass

            dispatcher.register("personal_tax", handler1)
            dispatcher.register("personal_tax", handler2)

            # Should have replaced, not added
            assert len(dispatcher.registered_types) == 1
            assert "personal_tax" in dispatcher.registered_types

        def test_is_registered(self) -> None:
            """is_registered returns correct state."""
            dispatcher = TaskDispatcher()

            async def mock_handler(task: Task) -> None:
                pass

            assert not dispatcher.is_registered("personal_tax")

            dispatcher.register("personal_tax", mock_handler)

            assert dispatcher.is_registered("personal_tax")
            assert not dispatcher.is_registered("business_tax")

        def test_unregister_removes_handler(self) -> None:
            """unregister removes registered handler."""
            dispatcher = TaskDispatcher()

            async def mock_handler(task: Task) -> None:
                pass

            dispatcher.register("personal_tax", mock_handler)
            result = dispatcher.unregister("personal_tax")

            assert result is True
            assert not dispatcher.is_registered("personal_tax")

        def test_unregister_nonexistent_returns_false(self) -> None:
            """unregister returns False for nonexistent type."""
            dispatcher = TaskDispatcher()

            result = dispatcher.unregister("nonexistent")

            assert result is False

        def test_registered_types_property(self) -> None:
            """registered_types returns all registered task types."""
            dispatcher = TaskDispatcher()

            async def mock_handler(task: Task) -> None:
                pass

            assert dispatcher.registered_types == []

            dispatcher.register("personal_tax", mock_handler)
            dispatcher.register("business_tax", mock_handler)
            dispatcher.register("bookkeeping", mock_handler)

            types = dispatcher.registered_types
            assert sorted(types) == ["bookkeeping", "business_tax", "personal_tax"]

        @pytest.mark.asyncio
        async def test_handler_exception_propagates(self) -> None:
            """Exceptions from handlers propagate to caller."""
            dispatcher = TaskDispatcher()

            async def failing_handler(task: Task) -> None:
                raise RuntimeError("Handler failed")

            dispatcher.register("personal_tax", failing_handler)
            task = self._create_task(task_type="personal_tax")

            with pytest.raises(RuntimeError) as exc_info:
                await dispatcher.dispatch(task)

            assert "Handler failed" in str(exc_info.value)

        def test_get_dispatcher_singleton(self) -> None:
            """get_dispatcher returns same instance."""
            reset_dispatcher()

            d1 = get_dispatcher()
            d2 = get_dispatcher()

            assert d1 is d2

        def test_reset_dispatcher_clears_singleton(self) -> None:
            """reset_dispatcher creates new instance on next get."""
            d1 = get_dispatcher()
            reset_dispatcher()
            d2 = get_dispatcher()

            assert d1 is not d2
    ```
  </action>
  <verify>
    - `pytest tests/orchestration/test_dispatcher.py -v` passes all tests
    - All dispatch scenarios covered (registered, unregistered, multiple types)
    - Error cases tested (empty type, handler exception)
  </verify>
  <done>Dispatcher tests pass, covering all routing scenarios</done>
</task>

</tasks>

<verification>
1. `python -c "from src.orchestration.dispatcher import TaskDispatcher"` imports successfully
2. `pytest tests/orchestration/test_dispatcher.py -v` passes all tests
3. TaskDispatcher correctly routes tasks to handlers by task_type
4. Unregistered task types raise ValueError with helpful message
</verification>

<success_criteria>
- TaskDispatcher class implemented with register/unregister/dispatch methods
- Dispatcher routes tasks to correct handler by task_type
- ValueError raised for unregistered task types
- All tests pass with full coverage of routing scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-framework/02-02-SUMMARY.md`
</output>
