---
phase: 02-core-framework
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01  # Dependency: pybreaker package installed in 02-01
files_modified:
  - src/orchestration/circuit_breaker.py
  - tests/orchestration/test_circuit_breaker.py
autonomous: true

must_haves:
  truths:
    - "Circuit breaker opens after 5 consecutive failures"
    - "Circuit breaker closes after 30 seconds timeout (enters half-open)"
    - "Circuit breaker requires 2 successes in half-open to close"
    - "Circuit breaker state persists in Redis across calls"
    - "All circuit breaker tests pass"
  artifacts:
    - path: "src/orchestration/circuit_breaker.py"
      provides: "LLM circuit breaker with Redis state"
      contains: "class CircuitBreaker"
    - path: "tests/orchestration/test_circuit_breaker.py"
      provides: "Circuit breaker test coverage"
      contains: "test_opens_after_5_failures"
  key_links:
    - from: "src/orchestration/circuit_breaker.py"
      to: "pybreaker"
      via: "import"
      pattern: "import pybreaker"
    - from: "src/orchestration/circuit_breaker.py"
      to: "redis"
      via: "import"
      pattern: "import redis"
---

<objective>
Implement circuit breaker for LLM API calls with Redis-backed state persistence.

Purpose: Protect the system from cascading failures when LLM APIs are unavailable by implementing the circuit breaker pattern with configurable thresholds.

Output: Working CircuitBreaker class that opens after 5 failures, enters half-open after 30 seconds, and closes after 2 successes, with Redis persistence.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-framework/02-RESEARCH.md
@src/core/redis.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker with Redis storage</name>
  <files>src/orchestration/circuit_breaker.py</files>
  <action>
    Create src/orchestration/circuit_breaker.py:

    ```python
    """Circuit breaker for LLM API calls with Redis state persistence.

    Implements the circuit breaker pattern to protect against cascading failures
    when LLM APIs become unavailable. State is stored in Redis to share across
    workers and survive restarts.

    Configuration (from ROADMAP requirements):
    - fail_max: 5 consecutive failures to open circuit
    - reset_timeout: 30 seconds before trying again (half-open)
    - success_threshold: 2 successes in half-open to close circuit
    """

    import asyncio
    from enum import Enum
    from functools import wraps
    from typing import Any, Awaitable, Callable, TypeVar

    import pybreaker
    import redis as sync_redis
    import structlog

    logger = structlog.get_logger()

    T = TypeVar("T")


    class CircuitState(str, Enum):
        """Circuit breaker states."""

        CLOSED = "closed"  # Normal operation
        OPEN = "open"  # Failing, reject calls
        HALF_OPEN = "half-open"  # Testing if service recovered


    class CircuitBreakerError(Exception):
        """Raised when circuit breaker is open."""

        def __init__(self, breaker_name: str, state: CircuitState):
            self.breaker_name = breaker_name
            self.state = state
            super().__init__(
                f"Circuit breaker '{breaker_name}' is {state.value}. "
                "Service temporarily unavailable."
            )


    class CircuitBreaker:
        """Circuit breaker for protecting LLM API calls.

        Uses pybreaker with Redis storage for distributed state. Implements
        custom success threshold logic for half-open -> closed transition.

        Usage:
            # Create breaker (typically at startup)
            breaker = CircuitBreaker(
                redis_url="redis://localhost:6379/0",
                name="claude_api",
            )

            # Wrap async function
            @breaker.protect
            async def call_llm(prompt: str) -> str:
                return await anthropic_client.complete(prompt)

            # Or call directly
            result = await breaker.call(call_llm, prompt="Hello")

        Configuration:
            fail_max: 5 (ORCH-03: opens after 5 consecutive failures)
            reset_timeout: 30 (ORCH-04: closes after 30 seconds)
            success_threshold: 2 (ORCH-05: 2 successes in half-open to close)
        """

        def __init__(
            self,
            redis_url: str,
            name: str = "llm_breaker",
            fail_max: int = 5,
            reset_timeout: int = 30,
            success_threshold: int = 2,
        ):
            """Initialize circuit breaker with Redis storage.

            Args:
                redis_url: Redis connection URL for state storage
                name: Unique name for this circuit breaker
                fail_max: Number of failures before opening circuit
                reset_timeout: Seconds before transitioning to half-open
                success_threshold: Successes needed in half-open to close
            """
            self.name = name
            self.fail_max = fail_max
            self.reset_timeout = reset_timeout
            self.success_threshold = success_threshold

            # Create sync Redis client for pybreaker
            # pybreaker doesn't support async Redis
            self._redis = sync_redis.Redis.from_url(
                redis_url,
                decode_responses=True,
            )

            # Create pybreaker with Redis storage
            self._breaker = pybreaker.CircuitBreaker(
                fail_max=fail_max,
                reset_timeout=reset_timeout,
                state_storage=pybreaker.CircuitRedisStorage(
                    pybreaker.STATE_CLOSED,
                    self._redis,
                    namespace=f"circuit_breaker:{name}",
                ),
                listeners=[self._create_listener()],
            )

            # Track half-open successes (stored in Redis for distributed)
            self._half_open_key = f"circuit_breaker:{name}:half_open_successes"

        def _create_listener(self) -> pybreaker.CircuitBreakerListener:
            """Create listener for state change logging."""

            class StateLogger(pybreaker.CircuitBreakerListener):
                def __init__(self, breaker_name: str):
                    self.breaker_name = breaker_name

                def state_change(
                    self, cb: pybreaker.CircuitBreaker, old_state: str, new_state: str
                ) -> None:
                    logger.warning(
                        "circuit_breaker_state_change",
                        breaker=self.breaker_name,
                        old_state=old_state,
                        new_state=new_state,
                    )

                def failure(self, cb: pybreaker.CircuitBreaker, exc: Exception) -> None:
                    logger.warning(
                        "circuit_breaker_failure",
                        breaker=self.breaker_name,
                        fail_counter=cb.fail_counter,
                        error=str(exc),
                    )

                def success(self, cb: pybreaker.CircuitBreaker) -> None:
                    logger.debug(
                        "circuit_breaker_success",
                        breaker=self.breaker_name,
                    )

            return StateLogger(self.name)

        @property
        def state(self) -> CircuitState:
            """Get current circuit state."""
            state_str = self._breaker.current_state
            if state_str == "closed":
                return CircuitState.CLOSED
            elif state_str == "open":
                return CircuitState.OPEN
            else:  # half-open
                return CircuitState.HALF_OPEN

        @property
        def fail_counter(self) -> int:
            """Get current failure count."""
            return self._breaker.fail_counter

        def _get_half_open_successes(self) -> int:
            """Get half-open success count from Redis."""
            val = self._redis.get(self._half_open_key)
            return int(val) if val else 0

        def _increment_half_open_successes(self) -> int:
            """Increment and return half-open success count."""
            return self._redis.incr(self._half_open_key)

        def _reset_half_open_successes(self) -> None:
            """Reset half-open success count."""
            self._redis.delete(self._half_open_key)

        def _record_success(self) -> None:
            """Record success, handle half-open -> closed transition."""
            if self.state == CircuitState.HALF_OPEN:
                count = self._increment_half_open_successes()
                logger.debug(
                    "circuit_breaker_half_open_success",
                    breaker=self.name,
                    success_count=count,
                    threshold=self.success_threshold,
                )
                if count >= self.success_threshold:
                    # pybreaker will transition when we call its success method
                    # but we need to reset our counter
                    self._reset_half_open_successes()
                    logger.info(
                        "circuit_breaker_closing",
                        breaker=self.name,
                        message="Success threshold reached, closing circuit",
                    )

        def _record_failure(self) -> None:
            """Record failure, reset half-open counter."""
            if self.state == CircuitState.HALF_OPEN:
                self._reset_half_open_successes()
                logger.warning(
                    "circuit_breaker_half_open_failure",
                    breaker=self.name,
                    message="Failure in half-open, reopening circuit",
                )

        async def call(
            self,
            func: Callable[..., Awaitable[T]],
            *args: Any,
            **kwargs: Any,
        ) -> T:
            """Execute async function with circuit breaker protection.

            Args:
                func: Async function to call
                *args: Positional arguments for func
                **kwargs: Keyword arguments for func

            Returns:
                Result from func

            Raises:
                CircuitBreakerError: If circuit is open
                Exception: Any exception from func (also recorded as failure)
            """
            # Check if circuit is open
            if self.state == CircuitState.OPEN:
                raise CircuitBreakerError(self.name, self.state)

            try:
                # Execute the async function
                result = await func(*args, **kwargs)

                # Record success (sync operation with Redis)
                self._breaker.call(lambda: None)  # Trick to record success
                self._record_success()

                return result

            except pybreaker.CircuitBreakerError:
                raise CircuitBreakerError(self.name, self.state)

            except Exception as e:
                # Record failure
                try:
                    self._breaker.call(self._raise_exc, e)
                except (pybreaker.CircuitBreakerError, Exception):
                    pass  # Expected - we're recording the failure

                self._record_failure()
                raise

        @staticmethod
        def _raise_exc(exc: Exception) -> None:
            """Helper to raise exception for pybreaker recording."""
            raise exc

        def protect(
            self, func: Callable[..., Awaitable[T]]
        ) -> Callable[..., Awaitable[T]]:
            """Decorator to protect an async function with circuit breaker.

            Usage:
                @breaker.protect
                async def call_llm(prompt: str) -> str:
                    ...
            """

            @wraps(func)
            async def wrapper(*args: Any, **kwargs: Any) -> T:
                return await self.call(func, *args, **kwargs)

            return wrapper

        def reset(self) -> None:
            """Reset circuit breaker to closed state.

            Use with caution - primarily for testing or manual recovery.
            """
            # Close the breaker
            self._breaker._state_storage.state = pybreaker.STATE_CLOSED
            self._reset_half_open_successes()
            logger.info(
                "circuit_breaker_reset",
                breaker=self.name,
            )

        def close(self) -> None:
            """Close Redis connection."""
            self._redis.close()


    # Factory for creating circuit breakers
    _breakers: dict[str, CircuitBreaker] = {}


    def get_circuit_breaker(
        redis_url: str,
        name: str = "llm_breaker",
        fail_max: int = 5,
        reset_timeout: int = 30,
        success_threshold: int = 2,
    ) -> CircuitBreaker:
        """Get or create a circuit breaker by name.

        Reuses existing breakers to avoid duplicate Redis connections.

        Args:
            redis_url: Redis connection URL
            name: Unique breaker name
            fail_max: Failures before opening
            reset_timeout: Seconds before half-open
            success_threshold: Successes to close

        Returns:
            CircuitBreaker instance
        """
        if name not in _breakers:
            _breakers[name] = CircuitBreaker(
                redis_url=redis_url,
                name=name,
                fail_max=fail_max,
                reset_timeout=reset_timeout,
                success_threshold=success_threshold,
            )
        return _breakers[name]


    def reset_all_breakers() -> None:
        """Reset all circuit breakers. Primarily for testing."""
        for breaker in _breakers.values():
            breaker.reset()
            breaker.close()
        _breakers.clear()


    __all__ = [
        "CircuitBreaker",
        "CircuitBreakerError",
        "CircuitState",
        "get_circuit_breaker",
        "reset_all_breakers",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.orchestration.circuit_breaker import CircuitBreaker, CircuitState"` succeeds
    - Module contains CircuitBreaker class with call/protect methods
  </verify>
  <done>CircuitBreaker class exists with Redis storage and configurable thresholds</done>
</task>

<task type="auto">
  <name>Task 2: Update orchestration __init__.py with circuit breaker exports</name>
  <files>src/orchestration/__init__.py</files>
  <action>
    Update src/orchestration/__init__.py to include circuit breaker exports:

    ```python
    """Orchestration module for task management and routing.

    Provides:
    - TaskStateMachine: Declarative state machine for task lifecycle
    - TaskDispatcher: Routes tasks to agent handlers by type
    - CircuitBreaker: Protects LLM calls with circuit breaker pattern
    """

    from src.orchestration.circuit_breaker import (
        CircuitBreaker,
        CircuitBreakerError,
        CircuitState,
        get_circuit_breaker,
        reset_all_breakers,
    )
    from src.orchestration.dispatcher import (
        AgentHandler,
        TaskDispatcher,
        get_dispatcher,
        reset_dispatcher,
    )
    from src.orchestration.state_machine import (
        TaskStateMachine,
        TransitionNotAllowed,
        create_state_machine,
    )

    __all__ = [
        # State machine
        "TaskStateMachine",
        "TransitionNotAllowed",
        "create_state_machine",
        # Dispatcher
        "TaskDispatcher",
        "AgentHandler",
        "get_dispatcher",
        "reset_dispatcher",
        # Circuit breaker
        "CircuitBreaker",
        "CircuitBreakerError",
        "CircuitState",
        "get_circuit_breaker",
        "reset_all_breakers",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.orchestration import CircuitBreaker, CircuitState"` succeeds
  </verify>
  <done>Orchestration module exports circuit breaker classes</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive circuit breaker tests</name>
  <files>tests/orchestration/test_circuit_breaker.py</files>
  <action>
    Create tests/orchestration/test_circuit_breaker.py:

    ```python
    """Tests for circuit breaker.

    These tests require a running Redis instance.
    Skip with: pytest -m "not redis" if Redis unavailable.
    """

    import asyncio

    import pytest
    import redis as sync_redis

    from src.orchestration.circuit_breaker import (
        CircuitBreaker,
        CircuitBreakerError,
        CircuitState,
        reset_all_breakers,
    )


    # Check if Redis is available
    def redis_available() -> bool:
        try:
            r = sync_redis.Redis.from_url("redis://localhost:6379/0")
            r.ping()
            r.close()
            return True
        except Exception:
            return False


    pytestmark = pytest.mark.skipif(
        not redis_available(), reason="Redis not available"
    )


    class TestCircuitBreaker:
        """Tests for CircuitBreaker functionality."""

        @pytest.fixture(autouse=True)
        def setup_teardown(self) -> None:
            """Reset circuit breakers before and after each test."""
            reset_all_breakers()
            yield
            reset_all_breakers()

        def _create_breaker(
            self,
            name: str = "test_breaker",
            fail_max: int = 5,
            reset_timeout: int = 30,
            success_threshold: int = 2,
        ) -> CircuitBreaker:
            """Create a circuit breaker for testing."""
            breaker = CircuitBreaker(
                redis_url="redis://localhost:6379/0",
                name=name,
                fail_max=fail_max,
                reset_timeout=reset_timeout,
                success_threshold=success_threshold,
            )
            # Ensure clean state
            breaker.reset()
            return breaker

        @pytest.mark.asyncio
        async def test_starts_closed(self) -> None:
            """Circuit breaker starts in closed state."""
            breaker = self._create_breaker()

            assert breaker.state == CircuitState.CLOSED
            assert breaker.fail_counter == 0

        @pytest.mark.asyncio
        async def test_successful_call_stays_closed(self) -> None:
            """Successful calls keep circuit closed."""
            breaker = self._create_breaker()

            async def success() -> str:
                return "ok"

            result = await breaker.call(success)

            assert result == "ok"
            assert breaker.state == CircuitState.CLOSED

        @pytest.mark.asyncio
        async def test_opens_after_5_failures(self) -> None:
            """Circuit opens after 5 consecutive failures (ORCH-03)."""
            breaker = self._create_breaker(fail_max=5)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Trigger 5 failures
            for i in range(5):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            # Circuit should now be open
            assert breaker.state == CircuitState.OPEN

        @pytest.mark.asyncio
        async def test_open_circuit_rejects_calls(self) -> None:
            """Open circuit rejects calls with CircuitBreakerError."""
            breaker = self._create_breaker(fail_max=2)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Open the circuit
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            assert breaker.state == CircuitState.OPEN

            # Now calls should be rejected
            async def would_succeed() -> str:
                return "ok"

            with pytest.raises(CircuitBreakerError) as exc_info:
                await breaker.call(would_succeed)

            assert "test_breaker" in str(exc_info.value)
            assert exc_info.value.state == CircuitState.OPEN

        @pytest.mark.asyncio
        async def test_half_open_after_timeout(self) -> None:
            """Circuit enters half-open after reset_timeout (ORCH-04)."""
            # Use very short timeout for testing
            breaker = self._create_breaker(fail_max=2, reset_timeout=1)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Open the circuit
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            assert breaker.state == CircuitState.OPEN

            # Wait for timeout
            await asyncio.sleep(1.5)

            # State should be half-open (pybreaker transitions on next call)
            # We need to check by attempting a call
            async def success() -> str:
                return "ok"

            # This call should be allowed (half-open allows test calls)
            result = await breaker.call(success)
            assert result == "ok"

        @pytest.mark.asyncio
        async def test_closes_after_2_successes_in_half_open(self) -> None:
            """Circuit closes after 2 successes in half-open (ORCH-05)."""
            # Use very short timeout for testing
            breaker = self._create_breaker(
                fail_max=2, reset_timeout=1, success_threshold=2
            )

            async def failing() -> None:
                raise RuntimeError("API error")

            async def success() -> str:
                return "ok"

            # Open the circuit
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            # Wait for half-open
            await asyncio.sleep(1.5)

            # First success in half-open
            await breaker.call(success)

            # Second success should close circuit
            await breaker.call(success)

            # Circuit should be closed
            assert breaker.state == CircuitState.CLOSED

        @pytest.mark.asyncio
        async def test_failure_in_half_open_reopens(self) -> None:
            """Failure in half-open reopens the circuit."""
            breaker = self._create_breaker(fail_max=2, reset_timeout=1)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Open the circuit
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            # Wait for half-open
            await asyncio.sleep(1.5)

            # Fail again in half-open
            with pytest.raises(RuntimeError):
                await breaker.call(failing)

            # Circuit should be open again
            assert breaker.state == CircuitState.OPEN

        @pytest.mark.asyncio
        async def test_protect_decorator(self) -> None:
            """@protect decorator works correctly."""
            breaker = self._create_breaker()

            @breaker.protect
            async def protected_function(value: int) -> int:
                return value * 2

            result = await protected_function(5)
            assert result == 10

        @pytest.mark.asyncio
        async def test_protect_decorator_with_failure(self) -> None:
            """@protect decorator handles failures."""
            breaker = self._create_breaker(fail_max=2)

            @breaker.protect
            async def protected_failing() -> None:
                raise ValueError("Test error")

            for _ in range(2):
                with pytest.raises(ValueError):
                    await protected_failing()

            assert breaker.state == CircuitState.OPEN

        @pytest.mark.asyncio
        async def test_success_resets_failure_count(self) -> None:
            """Success resets the failure counter."""
            breaker = self._create_breaker(fail_max=5)

            async def failing() -> None:
                raise RuntimeError("API error")

            async def success() -> str:
                return "ok"

            # 3 failures
            for _ in range(3):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            # Success should reset counter
            await breaker.call(success)

            # 3 more failures shouldn't open circuit
            for _ in range(3):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            # Circuit should still be closed (pybreaker resets on success)
            # Note: pybreaker may have different behavior - adjust test if needed
            assert breaker.fail_counter <= 3

        @pytest.mark.asyncio
        async def test_reset_method(self) -> None:
            """reset() returns circuit to closed state."""
            breaker = self._create_breaker(fail_max=2)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Open the circuit
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker.call(failing)

            assert breaker.state == CircuitState.OPEN

            # Reset should close it
            breaker.reset()

            assert breaker.state == CircuitState.CLOSED

        @pytest.mark.asyncio
        async def test_multiple_breakers_independent(self) -> None:
            """Different named breakers are independent."""
            breaker1 = self._create_breaker(name="breaker1", fail_max=2)
            breaker2 = self._create_breaker(name="breaker2", fail_max=2)

            async def failing() -> None:
                raise RuntimeError("API error")

            # Open breaker1
            for _ in range(2):
                with pytest.raises(RuntimeError):
                    await breaker1.call(failing)

            # breaker1 is open
            assert breaker1.state == CircuitState.OPEN

            # breaker2 should still be closed
            assert breaker2.state == CircuitState.CLOSED

            async def success() -> str:
                return "ok"

            # Can still call through breaker2
            result = await breaker2.call(success)
            assert result == "ok"
    ```
  </action>
  <verify>
    - `pytest tests/orchestration/test_circuit_breaker.py -v` passes all tests (requires Redis)
    - Tests cover: open after 5 failures, timeout, 2 successes to close, half-open behavior
  </verify>
  <done>Circuit breaker tests pass, covering all ORCH-03/04/05 requirements</done>
</task>

</tasks>

<verification>
1. `python -c "from src.orchestration.circuit_breaker import CircuitBreaker"` imports successfully
2. `pytest tests/orchestration/test_circuit_breaker.py -v` passes all tests
3. Circuit breaker opens after exactly 5 failures (ORCH-03)
4. Circuit breaker enters half-open after 30 seconds (ORCH-04)
5. Circuit breaker closes after 2 successes in half-open (ORCH-05)
</verification>

<success_criteria>
- CircuitBreaker class implemented with Redis state storage
- Circuit opens after 5 consecutive failures
- Circuit enters half-open after 30-second timeout
- Circuit closes after 2 successes in half-open state
- All tests pass (requires running Redis)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-framework/02-03-SUMMARY.md`
</output>
