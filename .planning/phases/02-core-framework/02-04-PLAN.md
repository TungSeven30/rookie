---
phase: 02-core-framework
plan: 04
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/skills/__init__.py
  - src/skills/models.py
  - src/skills/loader.py
  - src/skills/selector.py
  - tests/skills/__init__.py
  - tests/skills/test_loader.py
  - tests/skills/test_selector.py
  - skills/example_skill.yaml
autonomous: true

must_haves:
  truths:
    - "Skill loader parses valid YAML files into Pydantic models"
    - "Skill loader validates required fields (name, version, effective_date, instructions)"
    - "Skill selector returns correct version for given tax year"
    - "Skill selector returns None when no applicable version exists"
    - "All skill engine tests pass"
  artifacts:
    - path: "src/skills/models.py"
      provides: "Pydantic skill models"
      contains: "class SkillFile"
    - path: "src/skills/loader.py"
      provides: "YAML skill file parser"
      contains: "def load_skill_from_yaml"
    - path: "src/skills/selector.py"
      provides: "Version selection by effective_date"
      contains: "def select_skill_version"
  key_links:
    - from: "src/skills/models.py"
      to: "pydantic"
      via: "import"
      pattern: "from pydantic import"
    - from: "src/skills/loader.py"
      to: "ruamel.yaml"
      via: "import"
      pattern: "from ruamel.yaml import"
---

<objective>
Implement skill engine for parsing YAML skill files and selecting correct version by effective_date.

Purpose: Enable agents to load versioned skill files that describe how to perform specific tasks, with automatic selection of the correct version based on tax year.

Output: Working skill loader and selector that parse YAML skill files with Pydantic validation and select correct versions by effective_date.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-framework/02-RESEARCH.md
@src/models/skill.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models for skill files</name>
  <files>src/skills/__init__.py, src/skills/models.py</files>
  <action>
    1. Create src/skills/__init__.py (empty module init)

    2. Create src/skills/models.py:

    ```python
    """Pydantic models for skill file parsing and validation.

    Skill files are YAML documents that describe how agents should perform
    specific tasks. They are versioned with effective_date for tax law changes.

    Example skill file structure:
        metadata:
          name: personal_tax_w2
          version: "2024.1"
          effective_date: 2024-01-01
          description: W-2 income processing for personal tax returns
          tags: [personal_tax, income, w2]

        content:
          instructions: |
            Process W-2 forms by extracting...
          examples:
            - input: "W-2 with $50,000 wages"
              output: "Report on Line 1a"
          constraints:
            - Always verify EIN format
            - Cross-reference with prior year
    """

    from datetime import date
    from typing import Any

    from pydantic import BaseModel, Field, field_validator


    class SkillMetadata(BaseModel):
        """Metadata for a skill file.

        Contains versioning information and descriptive fields.
        """

        name: str = Field(
            ...,
            description="Unique skill name (e.g., 'personal_tax_w2')",
            min_length=1,
        )
        version: str = Field(
            ...,
            description="Version string (e.g., '2024.1')",
            min_length=1,
        )
        effective_date: date = Field(
            ...,
            description="Date this skill version becomes effective",
        )
        description: str | None = Field(
            default=None,
            description="Human-readable description of the skill",
        )
        tags: list[str] = Field(
            default_factory=list,
            description="Tags for categorization and search",
        )

        @field_validator("effective_date", mode="before")
        @classmethod
        def parse_date(cls, v: Any) -> date:
            """Parse date from string or date object."""
            if isinstance(v, date):
                return v
            if isinstance(v, str):
                return date.fromisoformat(v)
            raise ValueError(f"Cannot parse date from {type(v)}: {v}")


    class SkillExample(BaseModel):
        """An example demonstrating skill usage.

        Examples help the agent understand expected behavior.
        """

        input: str = Field(
            ...,
            description="Example input or scenario",
        )
        output: str = Field(
            ...,
            description="Expected output or response",
        )
        explanation: str | None = Field(
            default=None,
            description="Optional explanation of reasoning",
        )


    class SkillContent(BaseModel):
        """The actual content/instructions of a skill.

        Contains the instructions that guide agent behavior.
        """

        instructions: str = Field(
            ...,
            description="Main instructions for the agent",
            min_length=1,
        )
        examples: list[SkillExample] = Field(
            default_factory=list,
            description="Example scenarios with expected outputs",
        )
        constraints: list[str] = Field(
            default_factory=list,
            description="Rules or constraints the agent must follow",
        )
        escalation_triggers: list[str] = Field(
            default_factory=list,
            description="Conditions that should trigger escalation",
        )


    class SkillFileModel(BaseModel):
        """Complete skill file model.

        Represents a parsed and validated skill YAML file.

        Note: Named SkillFileModel to avoid conflict with SQLAlchemy
        SkillFile in src/models/skill.py.
        """

        metadata: SkillMetadata = Field(
            ...,
            description="Skill versioning and descriptive metadata",
        )
        content: SkillContent = Field(
            ...,
            description="Skill instructions and examples",
        )

        @property
        def name(self) -> str:
            """Convenience accessor for skill name."""
            return self.metadata.name

        @property
        def version(self) -> str:
            """Convenience accessor for skill version."""
            return self.metadata.version

        @property
        def effective_date(self) -> date:
            """Convenience accessor for effective date."""
            return self.metadata.effective_date

        @property
        def instructions(self) -> str:
            """Convenience accessor for instructions."""
            return self.content.instructions

        def is_effective_for_date(self, target_date: date) -> bool:
            """Check if this skill version is effective for a given date.

            A skill is effective if its effective_date is on or before
            the target date.

            Args:
                target_date: Date to check effectiveness for

            Returns:
                True if skill is effective for target_date
            """
            return self.effective_date <= target_date

        def is_effective_for_tax_year(self, tax_year: int) -> bool:
            """Check if this skill version is effective for a tax year.

            Tax year effectiveness is determined by January 1 of that year.

            Args:
                tax_year: Tax year (e.g., 2024)

            Returns:
                True if skill is effective for tax_year
            """
            return self.is_effective_for_date(date(tax_year, 1, 1))


    __all__ = [
        "SkillMetadata",
        "SkillExample",
        "SkillContent",
        "SkillFileModel",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.skills.models import SkillFileModel, SkillMetadata"` succeeds
    - Models have all required fields with validation
  </verify>
  <done>Pydantic skill models exist with validation and helper methods</done>
</task>

<task type="auto">
  <name>Task 2: Create skill loader for parsing YAML files</name>
  <files>src/skills/loader.py</files>
  <action>
    Create src/skills/loader.py:

    ```python
    """Skill file loader for parsing YAML skill files.

    Provides functions to load and validate skill files from YAML.
    Uses ruamel.yaml for parsing and Pydantic for validation.
    """

    from pathlib import Path
    from typing import Any

    import structlog
    from pydantic import ValidationError
    from ruamel.yaml import YAML

    from src.skills.models import SkillFileModel

    logger = structlog.get_logger()


    class SkillLoadError(Exception):
        """Error loading or parsing a skill file."""

        def __init__(self, path: Path | str, reason: str):
            self.path = Path(path)
            self.reason = reason
            super().__init__(f"Failed to load skill from {path}: {reason}")


    def load_skill_from_yaml(path: Path | str) -> SkillFileModel:
        """Load a skill file from YAML.

        Args:
            path: Path to the YAML skill file

        Returns:
            Parsed and validated SkillFileModel

        Raises:
            SkillLoadError: If file cannot be read or parsed
        """
        path = Path(path)

        if not path.exists():
            raise SkillLoadError(path, "File not found")

        if not path.is_file():
            raise SkillLoadError(path, "Path is not a file")

        try:
            # Read YAML content
            yaml = YAML(typ="safe")
            with path.open("r", encoding="utf-8") as f:
                data = yaml.load(f)

            if data is None:
                raise SkillLoadError(path, "File is empty or contains no valid YAML")

            # Validate with Pydantic
            skill = SkillFileModel.model_validate(data)

            logger.debug(
                "skill_loaded",
                path=str(path),
                name=skill.name,
                version=skill.version,
                effective_date=str(skill.effective_date),
            )

            return skill

        except ValidationError as e:
            errors = "; ".join(
                f"{'.'.join(str(x) for x in err['loc'])}: {err['msg']}"
                for err in e.errors()
            )
            raise SkillLoadError(path, f"Validation failed: {errors}")

        except Exception as e:
            if isinstance(e, SkillLoadError):
                raise
            raise SkillLoadError(path, f"YAML parse error: {str(e)}")


    def load_skill_from_dict(data: dict[str, Any]) -> SkillFileModel:
        """Load a skill from a dictionary.

        Useful for loading skills from database or other sources.

        Args:
            data: Dictionary with skill file structure

        Returns:
            Parsed and validated SkillFileModel

        Raises:
            ValidationError: If data doesn't match schema
        """
        return SkillFileModel.model_validate(data)


    def load_skills_from_directory(
        directory: Path | str,
        pattern: str = "*.yaml",
    ) -> list[SkillFileModel]:
        """Load all skill files from a directory.

        Args:
            directory: Directory containing skill files
            pattern: Glob pattern for skill files (default: *.yaml)

        Returns:
            List of loaded skills (skips invalid files with warning)
        """
        directory = Path(directory)

        if not directory.exists():
            logger.warning(
                "skill_directory_not_found",
                directory=str(directory),
            )
            return []

        if not directory.is_dir():
            logger.warning(
                "skill_path_not_directory",
                path=str(directory),
            )
            return []

        skills: list[SkillFileModel] = []
        for path in directory.glob(pattern):
            try:
                skill = load_skill_from_yaml(path)
                skills.append(skill)
            except SkillLoadError as e:
                logger.warning(
                    "skill_load_failed",
                    path=str(path),
                    reason=e.reason,
                )

        logger.info(
            "skills_loaded_from_directory",
            directory=str(directory),
            count=len(skills),
        )

        return skills


    def validate_skill_yaml(path: Path | str) -> list[str]:
        """Validate a skill YAML file without loading.

        Returns list of validation errors (empty if valid).

        Args:
            path: Path to YAML file to validate

        Returns:
            List of error messages (empty if valid)
        """
        try:
            load_skill_from_yaml(path)
            return []
        except SkillLoadError as e:
            return [e.reason]
        except Exception as e:
            return [str(e)]


    __all__ = [
        "SkillLoadError",
        "load_skill_from_yaml",
        "load_skill_from_dict",
        "load_skills_from_directory",
        "validate_skill_yaml",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.skills.loader import load_skill_from_yaml"` succeeds
    - Loader handles YAML parsing and Pydantic validation
  </verify>
  <done>Skill loader exists with YAML parsing and validation</done>
</task>

<task type="auto">
  <name>Task 3: Create skill version selector</name>
  <files>src/skills/selector.py</files>
  <action>
    Create src/skills/selector.py:

    ```python
    """Skill version selector for choosing correct version by effective_date.

    Selects the appropriate skill version based on tax year, using
    effective_date to determine which version was in effect.
    """

    from datetime import date

    import structlog

    from src.skills.models import SkillFileModel

    logger = structlog.get_logger()


    def select_skill_version(
        skills: list[SkillFileModel],
        tax_year: int,
    ) -> SkillFileModel | None:
        """Select the skill version effective for a given tax year.

        Returns the skill with the latest effective_date that is on or
        before January 1 of the tax year. This ensures we use the most
        recent version that was in effect when the tax year began.

        Args:
            skills: List of skill file versions (usually same skill, different versions)
            tax_year: Tax year to select version for (e.g., 2024)

        Returns:
            The applicable skill version, or None if no version is effective

        Example:
            skills = [
                skill_v1 (effective: 2023-01-01),
                skill_v2 (effective: 2024-01-01),
                skill_v3 (effective: 2025-01-01),
            ]
            select_skill_version(skills, 2024)  # Returns skill_v2
            select_skill_version(skills, 2023)  # Returns skill_v1
            select_skill_version(skills, 2022)  # Returns None
        """
        if not skills:
            return None

        # Target date is January 1 of tax year
        target_date = date(tax_year, 1, 1)

        # Filter skills effective on or before target date
        applicable = [s for s in skills if s.is_effective_for_date(target_date)]

        if not applicable:
            logger.debug(
                "no_applicable_skill_version",
                tax_year=tax_year,
                target_date=str(target_date),
                earliest_available=str(min(s.effective_date for s in skills)),
            )
            return None

        # Return the one with the latest effective date
        selected = max(applicable, key=lambda s: s.effective_date)

        logger.debug(
            "skill_version_selected",
            name=selected.name,
            version=selected.version,
            effective_date=str(selected.effective_date),
            tax_year=tax_year,
        )

        return selected


    def select_skill_version_by_date(
        skills: list[SkillFileModel],
        target_date: date,
    ) -> SkillFileModel | None:
        """Select the skill version effective for a specific date.

        Similar to select_skill_version but uses an explicit date
        instead of tax year.

        Args:
            skills: List of skill file versions
            target_date: Date to select version for

        Returns:
            The applicable skill version, or None if no version is effective
        """
        if not skills:
            return None

        applicable = [s for s in skills if s.is_effective_for_date(target_date)]

        if not applicable:
            return None

        return max(applicable, key=lambda s: s.effective_date)


    def group_skills_by_name(
        skills: list[SkillFileModel],
    ) -> dict[str, list[SkillFileModel]]:
        """Group skills by their name.

        Useful when loading multiple skills from a directory and
        wanting to select versions for each distinct skill.

        Args:
            skills: List of skill files (potentially mixed names)

        Returns:
            Dictionary mapping skill name to list of versions
        """
        grouped: dict[str, list[SkillFileModel]] = {}

        for skill in skills:
            if skill.name not in grouped:
                grouped[skill.name] = []
            grouped[skill.name].append(skill)

        # Sort each group by effective_date
        for name in grouped:
            grouped[name].sort(key=lambda s: s.effective_date)

        return grouped


    def get_latest_skill(
        skills: list[SkillFileModel],
    ) -> SkillFileModel | None:
        """Get the skill with the latest effective_date.

        Useful for getting the most current version regardless of tax year.

        Args:
            skills: List of skill file versions

        Returns:
            Skill with latest effective_date, or None if list is empty
        """
        if not skills:
            return None
        return max(skills, key=lambda s: s.effective_date)


    __all__ = [
        "select_skill_version",
        "select_skill_version_by_date",
        "group_skills_by_name",
        "get_latest_skill",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.skills.selector import select_skill_version"` succeeds
    - Selector returns correct version based on tax year
  </verify>
  <done>Skill version selector exists with tax year selection logic</done>
</task>

<task type="auto">
  <name>Task 4: Update skills __init__.py with exports</name>
  <files>src/skills/__init__.py</files>
  <action>
    Update src/skills/__init__.py:

    ```python
    """Skills module for loading and selecting versioned skill files.

    Provides:
    - SkillFileModel: Pydantic model for skill file validation
    - load_skill_from_yaml: Load and validate skill from YAML file
    - select_skill_version: Select correct version by tax year
    """

    from src.skills.loader import (
        SkillLoadError,
        load_skill_from_dict,
        load_skill_from_yaml,
        load_skills_from_directory,
        validate_skill_yaml,
    )
    from src.skills.models import (
        SkillContent,
        SkillExample,
        SkillFileModel,
        SkillMetadata,
    )
    from src.skills.selector import (
        get_latest_skill,
        group_skills_by_name,
        select_skill_version,
        select_skill_version_by_date,
    )

    __all__ = [
        # Models
        "SkillFileModel",
        "SkillMetadata",
        "SkillContent",
        "SkillExample",
        # Loader
        "SkillLoadError",
        "load_skill_from_yaml",
        "load_skill_from_dict",
        "load_skills_from_directory",
        "validate_skill_yaml",
        # Selector
        "select_skill_version",
        "select_skill_version_by_date",
        "group_skills_by_name",
        "get_latest_skill",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.skills import SkillFileModel, load_skill_from_yaml, select_skill_version"` succeeds
  </verify>
  <done>Skills module exports all loader and selector functions</done>
</task>

<task type="auto">
  <name>Task 5: Create example skill file and tests</name>
  <files>skills/example_skill.yaml, tests/skills/__init__.py, tests/skills/test_loader.py, tests/skills/test_selector.py</files>
  <action>
    1. Create skills/ directory and skills/example_skill.yaml:

    ```yaml
    metadata:
      name: personal_tax_w2
      version: "2024.1"
      effective_date: 2024-01-01
      description: W-2 wage and income processing for personal tax returns
      tags:
        - personal_tax
        - income
        - w2

    content:
      instructions: |
        Process W-2 forms for personal tax returns by:
        1. Extract all wage and income information from Box 1
        2. Extract federal withholding from Box 2
        3. Verify Social Security wages (Box 3) and Medicare wages (Box 5)
        4. Record state wages and withholding if present

        Report wages on Form 1040, Line 1a.
        Cross-reference with prior year for significant changes (>10%).

      examples:
        - input: "W-2 showing $50,000 in Box 1 wages, $5,000 federal withholding"
          output: "Report $50,000 on Line 1a, $5,000 withheld taxes"
          explanation: "Standard W-2 processing with no special circumstances"

        - input: "Multiple W-2s totaling $75,000 wages"
          output: "Aggregate all W-2 Box 1 amounts, report $75,000 on Line 1a"
          explanation: "Combine wages from multiple employers"

      constraints:
        - Always verify EIN format (XX-XXXXXXX)
        - Cross-reference total wages with prior year
        - Flag if wages decreased by more than 20%

      escalation_triggers:
        - W-2 appears to have corrections (W-2c issued)
        - Box 12 contains unusual codes (not standard retirement)
        - Wages exceed $150,000 (potential NIIT consideration)
    ```

    2. Create tests/skills/__init__.py (empty)

    3. Create tests/skills/test_loader.py:

    ```python
    """Tests for skill file loader."""

    from datetime import date
    from pathlib import Path
    from textwrap import dedent

    import pytest

    from src.skills.loader import (
        SkillLoadError,
        load_skill_from_dict,
        load_skill_from_yaml,
        load_skills_from_directory,
        validate_skill_yaml,
    )
    from src.skills.models import SkillFileModel


    class TestLoadSkillFromYaml:
        """Tests for load_skill_from_yaml function."""

        def test_loads_valid_skill_file(self, tmp_path: Path) -> None:
            """Successfully loads a valid skill YAML file."""
            skill_yaml = dedent("""
                metadata:
                  name: test_skill
                  version: "1.0"
                  effective_date: 2024-01-01
                  description: A test skill
                  tags: [test]

                content:
                  instructions: Do the thing.
                  examples: []
                  constraints: []
            """)
            skill_file = tmp_path / "test_skill.yaml"
            skill_file.write_text(skill_yaml)

            skill = load_skill_from_yaml(skill_file)

            assert skill.name == "test_skill"
            assert skill.version == "1.0"
            assert skill.effective_date == date(2024, 1, 1)
            assert skill.instructions == "Do the thing."

        def test_raises_for_nonexistent_file(self, tmp_path: Path) -> None:
            """Raises SkillLoadError for nonexistent file."""
            with pytest.raises(SkillLoadError) as exc_info:
                load_skill_from_yaml(tmp_path / "nonexistent.yaml")

            assert "File not found" in str(exc_info.value)

        def test_raises_for_empty_file(self, tmp_path: Path) -> None:
            """Raises SkillLoadError for empty file."""
            skill_file = tmp_path / "empty.yaml"
            skill_file.write_text("")

            with pytest.raises(SkillLoadError) as exc_info:
                load_skill_from_yaml(skill_file)

            assert "empty" in str(exc_info.value).lower()

        def test_raises_for_missing_required_fields(self, tmp_path: Path) -> None:
            """Raises SkillLoadError for missing required fields."""
            skill_yaml = dedent("""
                metadata:
                  name: test_skill
                  # missing version, effective_date

                content:
                  instructions: Do the thing.
            """)
            skill_file = tmp_path / "invalid.yaml"
            skill_file.write_text(skill_yaml)

            with pytest.raises(SkillLoadError) as exc_info:
                load_skill_from_yaml(skill_file)

            assert "Validation failed" in str(exc_info.value)

        def test_raises_for_invalid_yaml(self, tmp_path: Path) -> None:
            """Raises SkillLoadError for invalid YAML syntax."""
            skill_file = tmp_path / "invalid.yaml"
            skill_file.write_text("not: valid: yaml: syntax")

            with pytest.raises(SkillLoadError):
                load_skill_from_yaml(skill_file)


    class TestLoadSkillFromDict:
        """Tests for load_skill_from_dict function."""

        def test_loads_valid_dict(self) -> None:
            """Successfully loads from a valid dictionary."""
            data = {
                "metadata": {
                    "name": "dict_skill",
                    "version": "1.0",
                    "effective_date": "2024-06-15",
                },
                "content": {
                    "instructions": "Do something.",
                },
            }

            skill = load_skill_from_dict(data)

            assert skill.name == "dict_skill"
            assert skill.effective_date == date(2024, 6, 15)


    class TestLoadSkillsFromDirectory:
        """Tests for load_skills_from_directory function."""

        def test_loads_all_yaml_files(self, tmp_path: Path) -> None:
            """Loads all .yaml files in directory."""
            for i in range(3):
                skill_yaml = dedent(f"""
                    metadata:
                      name: skill_{i}
                      version: "1.0"
                      effective_date: 2024-01-0{i+1}

                    content:
                      instructions: Skill {i} instructions.
                """)
                (tmp_path / f"skill_{i}.yaml").write_text(skill_yaml)

            skills = load_skills_from_directory(tmp_path)

            assert len(skills) == 3
            names = {s.name for s in skills}
            assert names == {"skill_0", "skill_1", "skill_2"}

        def test_skips_invalid_files(self, tmp_path: Path) -> None:
            """Skips invalid files with warning, loads valid ones."""
            # Valid skill
            valid_yaml = dedent("""
                metadata:
                  name: valid_skill
                  version: "1.0"
                  effective_date: 2024-01-01

                content:
                  instructions: Valid instructions.
            """)
            (tmp_path / "valid.yaml").write_text(valid_yaml)

            # Invalid skill (missing required fields)
            (tmp_path / "invalid.yaml").write_text("metadata:\n  name: only_name")

            skills = load_skills_from_directory(tmp_path)

            assert len(skills) == 1
            assert skills[0].name == "valid_skill"

        def test_returns_empty_for_nonexistent_directory(self, tmp_path: Path) -> None:
            """Returns empty list for nonexistent directory."""
            skills = load_skills_from_directory(tmp_path / "nonexistent")

            assert skills == []


    class TestValidateSkillYaml:
        """Tests for validate_skill_yaml function."""

        def test_returns_empty_for_valid_file(self, tmp_path: Path) -> None:
            """Returns empty list for valid file."""
            skill_yaml = dedent("""
                metadata:
                  name: valid
                  version: "1.0"
                  effective_date: 2024-01-01

                content:
                  instructions: Valid.
            """)
            skill_file = tmp_path / "valid.yaml"
            skill_file.write_text(skill_yaml)

            errors = validate_skill_yaml(skill_file)

            assert errors == []

        def test_returns_errors_for_invalid_file(self, tmp_path: Path) -> None:
            """Returns error messages for invalid file."""
            skill_file = tmp_path / "invalid.yaml"
            skill_file.write_text("invalid: yaml")

            errors = validate_skill_yaml(skill_file)

            assert len(errors) > 0
    ```

    4. Create tests/skills/test_selector.py:

    ```python
    """Tests for skill version selector."""

    from datetime import date

    import pytest

    from src.skills.models import SkillFileModel
    from src.skills.selector import (
        get_latest_skill,
        group_skills_by_name,
        select_skill_version,
        select_skill_version_by_date,
    )


    class TestSelectSkillVersion:
        """Tests for select_skill_version function."""

        def _create_skill(
            self,
            name: str = "test_skill",
            version: str = "1.0",
            effective_date: date = date(2024, 1, 1),
        ) -> SkillFileModel:
            """Create a skill for testing."""
            return SkillFileModel(
                metadata={
                    "name": name,
                    "version": version,
                    "effective_date": effective_date,
                },
                content={
                    "instructions": f"Instructions for {name} v{version}",
                },
            )

        def test_selects_correct_version_for_tax_year(self) -> None:
            """Selects the version effective for the tax year."""
            skills = [
                self._create_skill(version="2023.1", effective_date=date(2023, 1, 1)),
                self._create_skill(version="2024.1", effective_date=date(2024, 1, 1)),
                self._create_skill(version="2025.1", effective_date=date(2025, 1, 1)),
            ]

            result = select_skill_version(skills, tax_year=2024)

            assert result is not None
            assert result.version == "2024.1"

        def test_selects_most_recent_applicable_version(self) -> None:
            """When multiple versions apply, selects most recent."""
            skills = [
                self._create_skill(version="2023.1", effective_date=date(2023, 1, 1)),
                self._create_skill(version="2023.2", effective_date=date(2023, 7, 1)),
                self._create_skill(version="2024.1", effective_date=date(2024, 1, 1)),
            ]

            # For tax year 2024, both 2023.1 and 2023.2 were effective before Jan 1 2024
            # 2024.1 is exactly on Jan 1 2024, so it should be selected
            result = select_skill_version(skills, tax_year=2024)

            assert result is not None
            assert result.version == "2024.1"

        def test_returns_none_when_no_version_applicable(self) -> None:
            """Returns None when no version is effective for tax year."""
            skills = [
                self._create_skill(version="2025.1", effective_date=date(2025, 1, 1)),
                self._create_skill(version="2026.1", effective_date=date(2026, 1, 1)),
            ]

            result = select_skill_version(skills, tax_year=2024)

            assert result is None

        def test_returns_none_for_empty_list(self) -> None:
            """Returns None for empty skill list."""
            result = select_skill_version([], tax_year=2024)

            assert result is None

        def test_handles_mid_year_effective_dates(self) -> None:
            """Mid-year effective dates don't affect tax year selection."""
            skills = [
                self._create_skill(version="2023.1", effective_date=date(2023, 1, 1)),
                self._create_skill(version="2023.2", effective_date=date(2023, 7, 1)),
            ]

            # For tax year 2024 (Jan 1 2024), 2023.2 is the most recent effective
            result = select_skill_version(skills, tax_year=2024)

            assert result is not None
            assert result.version == "2023.2"

        def test_exact_match_on_jan_1(self) -> None:
            """Skill effective exactly on Jan 1 of tax year is selected."""
            skills = [
                self._create_skill(version="2023.1", effective_date=date(2023, 1, 1)),
                self._create_skill(version="2024.1", effective_date=date(2024, 1, 1)),
            ]

            result = select_skill_version(skills, tax_year=2024)

            assert result is not None
            assert result.version == "2024.1"


    class TestSelectSkillVersionByDate:
        """Tests for select_skill_version_by_date function."""

        def _create_skill(
            self,
            version: str = "1.0",
            effective_date: date = date(2024, 1, 1),
        ) -> SkillFileModel:
            """Create a skill for testing."""
            return SkillFileModel(
                metadata={
                    "name": "test_skill",
                    "version": version,
                    "effective_date": effective_date,
                },
                content={"instructions": "Test"},
            )

        def test_selects_for_specific_date(self) -> None:
            """Selects version effective for specific date."""
            skills = [
                self._create_skill(version="1.0", effective_date=date(2024, 1, 1)),
                self._create_skill(version="2.0", effective_date=date(2024, 7, 1)),
            ]

            # April 15 should use version 1.0
            result = select_skill_version_by_date(skills, date(2024, 4, 15))
            assert result is not None
            assert result.version == "1.0"

            # August 1 should use version 2.0
            result = select_skill_version_by_date(skills, date(2024, 8, 1))
            assert result is not None
            assert result.version == "2.0"


    class TestGroupSkillsByName:
        """Tests for group_skills_by_name function."""

        def test_groups_skills_by_name(self) -> None:
            """Groups skills with same name together."""
            skills = [
                SkillFileModel(
                    metadata={"name": "skill_a", "version": "1.0", "effective_date": date(2024, 1, 1)},
                    content={"instructions": "A1"},
                ),
                SkillFileModel(
                    metadata={"name": "skill_b", "version": "1.0", "effective_date": date(2024, 1, 1)},
                    content={"instructions": "B1"},
                ),
                SkillFileModel(
                    metadata={"name": "skill_a", "version": "2.0", "effective_date": date(2025, 1, 1)},
                    content={"instructions": "A2"},
                ),
            ]

            grouped = group_skills_by_name(skills)

            assert len(grouped) == 2
            assert len(grouped["skill_a"]) == 2
            assert len(grouped["skill_b"]) == 1


    class TestGetLatestSkill:
        """Tests for get_latest_skill function."""

        def test_returns_latest_by_effective_date(self) -> None:
            """Returns skill with latest effective_date."""
            skills = [
                SkillFileModel(
                    metadata={"name": "skill", "version": "1.0", "effective_date": date(2023, 1, 1)},
                    content={"instructions": "Old"},
                ),
                SkillFileModel(
                    metadata={"name": "skill", "version": "2.0", "effective_date": date(2025, 1, 1)},
                    content={"instructions": "New"},
                ),
                SkillFileModel(
                    metadata={"name": "skill", "version": "1.5", "effective_date": date(2024, 1, 1)},
                    content={"instructions": "Mid"},
                ),
            ]

            result = get_latest_skill(skills)

            assert result is not None
            assert result.version == "2.0"

        def test_returns_none_for_empty_list(self) -> None:
            """Returns None for empty list."""
            assert get_latest_skill([]) is None
    ```
  </action>
  <verify>
    - `pytest tests/skills/ -v` passes all tests
    - Example skill file at skills/example_skill.yaml is valid
    - `python -c "from src.skills.loader import load_skill_from_yaml; s = load_skill_from_yaml('skills/example_skill.yaml'); print(s.name)"` prints "personal_tax_w2"
  </verify>
  <done>Skill engine tests pass, example skill file validates correctly</done>
</task>

</tasks>

<verification>
1. `python -c "from src.skills import SkillFileModel, load_skill_from_yaml, select_skill_version"` imports successfully
2. `pytest tests/skills/ -v` passes all tests
3. Example skill file loads without error: `python -c "from src.skills import load_skill_from_yaml; print(load_skill_from_yaml('skills/example_skill.yaml').name)"`
4. Version selector returns correct skill for tax year
</verification>

<success_criteria>
- SkillFileModel validates all required fields (name, version, effective_date, instructions)
- Skill loader parses YAML files with Pydantic validation
- Version selector returns correct version for given tax year
- All tests pass with full coverage of loader and selector
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-framework/02-04-SUMMARY.md`
</output>
