---
phase: 02-core-framework
plan: 05
type: execute
wave: 3
depends_on:
  - 02-04
files_modified:
  - src/context/__init__.py
  - src/context/profile.py
  - src/context/builder.py
  - tests/context/__init__.py
  - tests/context/test_profile.py
  - tests/context/test_builder.py
autonomous: true

must_haves:
  truths:
    - "Client profile computed view derives current state from append-only log"
    - "Profile view returns latest entry per entry_type"
    - "append_profile_entry creates new entries (never updates)"
    - "Context builder assembles profile + documents + skills for agent"
    - "All context tests pass"
  artifacts:
    - path: "src/context/profile.py"
      provides: "Client profile computed view from append-only log"
      contains: "async def get_client_profile_view"
    - path: "src/context/builder.py"
      provides: "Context assembly for agent execution"
      contains: "class AgentContext"
  key_links:
    - from: "src/context/profile.py"
      to: "src/models/client.py"
      via: "import"
      pattern: "from src.models.client import ClientProfileEntry"
    - from: "src/context/builder.py"
      to: "src/context/profile.py"
      via: "import"
      pattern: "from src.context.profile import"
---

<objective>
Implement client profile service with append-only log pattern and context builder for agent execution.

Purpose: Provide computed views of client profiles from append-only log entries and assemble complete context (profile + documents + skills) for agent execution.

Output: Working profile service that computes current state from log and context builder that assembles agent execution context.
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-framework/02-RESEARCH.md
@src/models/client.py
@src/skills/selector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile service with computed view</name>
  <files>src/context/__init__.py, src/context/profile.py</files>
  <action>
    1. Create src/context/__init__.py (empty module init)

    2. Create src/context/profile.py:

    ```python
    """Client profile service with append-only log pattern.

    Provides functions to:
    - Append new profile entries (never update existing)
    - Compute current profile state from log using window functions
    - Query profile history for specific entry types

    The append-only pattern eliminates merge conflicts and provides
    full history of all profile changes.
    """

    from datetime import datetime
    from typing import Any

    import structlog
    from sqlalchemy import func, select
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.models.client import Client, ClientProfileEntry

    logger = structlog.get_logger()


    async def get_client_profile_view(
        session: AsyncSession,
        client_id: int,
    ) -> dict[str, Any]:
        """Compute current client profile state from append-only log.

        Uses window functions to get the latest entry per entry_type.
        This is the "computed view" pattern from event sourcing.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID to get profile for

        Returns:
            Dictionary mapping entry_type to its latest data

        Example:
            profile = await get_client_profile_view(session, client_id=1)
            # {
            #     "income_sources": {"w2": True, "self_employment": False},
            #     "filing_status": {"status": "married_jointly"},
            #     "contact_info": {"email": "user@example.com"},
            # }
        """
        # Subquery: rank entries by type, most recent first
        ranked_subq = (
            select(
                ClientProfileEntry.entry_type,
                ClientProfileEntry.data,
                func.row_number()
                .over(
                    partition_by=ClientProfileEntry.entry_type,
                    order_by=ClientProfileEntry.created_at.desc(),
                )
                .label("rn"),
            )
            .where(ClientProfileEntry.client_id == client_id)
            .subquery()
        )

        # Get only the latest entry per type (rn = 1)
        query = select(
            ranked_subq.c.entry_type,
            ranked_subq.c.data,
        ).where(ranked_subq.c.rn == 1)

        result = await session.execute(query)
        rows = result.fetchall()

        # Build profile dict from latest entries
        profile: dict[str, Any] = {}
        for entry_type, data in rows:
            profile[entry_type] = data

        logger.debug(
            "profile_view_computed",
            client_id=client_id,
            entry_count=len(profile),
            entry_types=list(profile.keys()),
        )

        return profile


    async def append_profile_entry(
        session: AsyncSession,
        client_id: int,
        entry_type: str,
        data: dict[str, Any],
    ) -> ClientProfileEntry:
        """Append a new entry to client profile log.

        This function NEVER updates existing entries. It always creates
        a new entry, preserving full history.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID to add entry for
            entry_type: Type of profile data (e.g., "income_sources")
            data: Profile data as dictionary

        Returns:
            The created ClientProfileEntry

        Note:
            Caller is responsible for committing the session.
        """
        entry = ClientProfileEntry(
            client_id=client_id,
            entry_type=entry_type,
            data=data,
        )
        session.add(entry)
        await session.flush()

        logger.info(
            "profile_entry_appended",
            client_id=client_id,
            entry_type=entry_type,
            entry_id=entry.id,
        )

        return entry


    async def get_profile_history(
        session: AsyncSession,
        client_id: int,
        entry_type: str | None = None,
        limit: int = 100,
    ) -> list[ClientProfileEntry]:
        """Get profile entry history for a client.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID to get history for
            entry_type: Optional filter by entry type
            limit: Maximum entries to return

        Returns:
            List of profile entries, most recent first
        """
        query = (
            select(ClientProfileEntry)
            .where(ClientProfileEntry.client_id == client_id)
            .order_by(ClientProfileEntry.created_at.desc())
            .limit(limit)
        )

        if entry_type is not None:
            query = query.where(ClientProfileEntry.entry_type == entry_type)

        result = await session.execute(query)
        entries = list(result.scalars().all())

        return entries


    async def get_client_with_profile(
        session: AsyncSession,
        client_id: int,
    ) -> tuple[Client | None, dict[str, Any]]:
        """Get client and computed profile in single operation.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID to fetch

        Returns:
            Tuple of (Client or None, profile dict)
        """
        # Get client
        result = await session.execute(
            select(Client).where(Client.id == client_id)
        )
        client = result.scalar_one_or_none()

        if client is None:
            return None, {}

        # Get computed profile
        profile = await get_client_profile_view(session, client_id)

        return client, profile


    async def profile_entry_count(
        session: AsyncSession,
        client_id: int,
    ) -> int:
        """Count total profile entries for a client.

        Useful for monitoring append-only log growth.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID to count entries for

        Returns:
            Total number of profile entries
        """
        result = await session.execute(
            select(func.count(ClientProfileEntry.id)).where(
                ClientProfileEntry.client_id == client_id
            )
        )
        return result.scalar() or 0


    __all__ = [
        "get_client_profile_view",
        "append_profile_entry",
        "get_profile_history",
        "get_client_with_profile",
        "profile_entry_count",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.context.profile import get_client_profile_view, append_profile_entry"` succeeds
    - Module provides computed view and append functions
  </verify>
  <done>Profile service exists with computed view and append-only log functions</done>
</task>

<task type="auto">
  <name>Task 2: Create context builder for agent execution</name>
  <files>src/context/builder.py</files>
  <action>
    Create src/context/builder.py:

    ```python
    """Context builder for assembling agent execution context.

    Combines client profile, documents, and skills into a complete
    context for agent execution. This is the "context assembly" phase
    before an agent starts processing a task.
    """

    from dataclasses import dataclass, field
    from datetime import date
    from typing import Any

    import structlog
    from sqlalchemy import select
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.context.profile import get_client_profile_view
    from src.models.artifact import DocumentEmbedding
    from src.models.client import Client
    from src.models.skill import SkillFile
    from src.skills.models import SkillFileModel
    from src.skills.selector import select_skill_version

    logger = structlog.get_logger()


    @dataclass
    class AgentContext:
        """Complete context for agent execution.

        Contains all information an agent needs to process a task:
        - Client profile (computed view from append-only log)
        - Relevant documents (extracted content for tax year)
        - Skill instructions (selected for task type and tax year)
        - Optional prior year return for comparison
        """

        client_id: int
        client_name: str
        tax_year: int
        task_type: str

        # Client profile (from append-only log computed view)
        client_profile: dict[str, Any] = field(default_factory=dict)

        # Extracted documents relevant to this task
        documents: list[dict[str, Any]] = field(default_factory=list)

        # Skill instructions (text, not full model)
        skills: list[str] = field(default_factory=list)

        # Prior year return for comparison (optional)
        prior_year_return: dict[str, Any] | None = None

        def to_prompt_context(self) -> str:
            """Convert context to prompt-ready format.

            Returns formatted string suitable for including in agent prompt.
            """
            sections = []

            # Client section
            sections.append(f"## Client: {self.client_name}")
            sections.append(f"Tax Year: {self.tax_year}")
            sections.append(f"Task Type: {self.task_type}")
            sections.append("")

            # Profile section
            if self.client_profile:
                sections.append("## Client Profile")
                for entry_type, data in self.client_profile.items():
                    sections.append(f"### {entry_type}")
                    if isinstance(data, dict):
                        for k, v in data.items():
                            sections.append(f"- {k}: {v}")
                    else:
                        sections.append(f"{data}")
                sections.append("")

            # Documents section
            if self.documents:
                sections.append(f"## Documents ({len(self.documents)})")
                for doc in self.documents:
                    doc_type = doc.get("type", "Unknown")
                    sections.append(f"### {doc_type}")
                    content = doc.get("content", {})
                    if isinstance(content, dict):
                        for k, v in content.items():
                            sections.append(f"- {k}: {v}")
                    sections.append("")

            # Prior year section
            if self.prior_year_return:
                sections.append("## Prior Year Return")
                for k, v in self.prior_year_return.items():
                    sections.append(f"- {k}: {v}")
                sections.append("")

            return "\n".join(sections)


    # Mapping of task types to skill names
    TASK_TYPE_SKILLS: dict[str, list[str]] = {
        "personal_tax": [
            "personal_tax_w2",
            "personal_tax_1099",
            "personal_tax_deductions",
        ],
        "business_tax": [
            "business_tax_1120s",
            "business_tax_k1",
        ],
        "bookkeeping": [
            "bookkeeping_categorization",
            "bookkeeping_reconciliation",
        ],
    }


    def get_skills_for_task_type(task_type: str) -> list[str]:
        """Get skill names needed for a task type.

        Args:
            task_type: Type of task (e.g., "personal_tax")

        Returns:
            List of skill names to load
        """
        return TASK_TYPE_SKILLS.get(task_type, [])


    async def load_skill_for_year(
        session: AsyncSession,
        skill_name: str,
        tax_year: int,
    ) -> SkillFileModel | None:
        """Load a skill from database and select version for tax year.

        Args:
            session: SQLAlchemy async session
            skill_name: Name of skill to load
            tax_year: Tax year to select version for

        Returns:
            Selected skill version, or None if not found
        """
        # Query all versions of this skill from database
        result = await session.execute(
            select(SkillFile).where(SkillFile.name == skill_name)
        )
        skill_files = result.scalars().all()

        if not skill_files:
            logger.warning(
                "skill_not_found",
                skill_name=skill_name,
            )
            return None

        # Convert to Pydantic models
        skill_models = []
        for sf in skill_files:
            try:
                # Parse stored content (assumed to be YAML or dict)
                import yaml

                if isinstance(sf.content, str):
                    data = yaml.safe_load(sf.content)
                else:
                    data = sf.content

                # Create Pydantic model
                model = SkillFileModel(
                    metadata={
                        "name": sf.name,
                        "version": sf.version,
                        "effective_date": sf.effective_date,
                    },
                    content=data.get("content", {"instructions": sf.content}),
                )
                skill_models.append(model)
            except Exception as e:
                logger.warning(
                    "skill_parse_error",
                    skill_name=skill_name,
                    version=sf.version,
                    error=str(e),
                )

        if not skill_models:
            return None

        # Select version for tax year
        return select_skill_version(skill_models, tax_year)


    async def get_client_documents(
        session: AsyncSession,
        client_id: int,
        tax_year: int,
    ) -> list[dict[str, Any]]:
        """Get extracted documents for a client and tax year.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID
            tax_year: Tax year to get documents for

        Returns:
            List of document dictionaries with type and content
        """
        # Query document embeddings (which contain extracted content)
        # In a real implementation, would query a documents table
        # For now, return empty list - documents will be added in Phase 3

        logger.debug(
            "get_client_documents",
            client_id=client_id,
            tax_year=tax_year,
            message="Document retrieval not implemented - Phase 3",
        )

        return []


    async def get_prior_year_return(
        session: AsyncSession,
        client_id: int,
        tax_year: int,
    ) -> dict[str, Any] | None:
        """Get prior year return for comparison.

        Args:
            session: SQLAlchemy async session
            client_id: Client ID
            tax_year: The prior tax year to retrieve

        Returns:
            Prior year return data, or None if not available
        """
        # Query prior year return from task artifacts or dedicated table
        # For now, return None - prior year comparison in Phase 3

        logger.debug(
            "get_prior_year_return",
            client_id=client_id,
            tax_year=tax_year,
            message="Prior year retrieval not implemented - Phase 3",
        )

        return None


    async def build_agent_context(
        session: AsyncSession,
        client_id: int,
        task_type: str,
        tax_year: int,
    ) -> AgentContext:
        """Build complete context for agent execution.

        Assembles:
        - Client profile (computed view from append-only log)
        - Extracted documents for tax year
        - Relevant skills selected by task type and effective date
        - Prior year return for comparison (if available)

        Args:
            session: SQLAlchemy async session
            client_id: Client ID
            task_type: Type of task (determines which skills to load)
            tax_year: Tax year being processed

        Returns:
            Complete AgentContext for agent execution
        """
        # 1. Get client and profile
        result = await session.execute(
            select(Client).where(Client.id == client_id)
        )
        client = result.scalar_one_or_none()

        if client is None:
            raise ValueError(f"Client not found: {client_id}")

        profile = await get_client_profile_view(session, client_id)

        # 2. Get extracted documents
        documents = await get_client_documents(session, client_id, tax_year)

        # 3. Get relevant skills
        skill_names = get_skills_for_task_type(task_type)
        skills: list[str] = []

        for name in skill_names:
            skill = await load_skill_for_year(session, name, tax_year)
            if skill:
                skills.append(skill.instructions)

        # 4. Get prior year return
        prior_year = await get_prior_year_return(session, client_id, tax_year - 1)

        context = AgentContext(
            client_id=client_id,
            client_name=client.name,
            tax_year=tax_year,
            task_type=task_type,
            client_profile=profile,
            documents=documents,
            skills=skills,
            prior_year_return=prior_year,
        )

        logger.info(
            "agent_context_built",
            client_id=client_id,
            task_type=task_type,
            tax_year=tax_year,
            profile_entries=len(profile),
            document_count=len(documents),
            skill_count=len(skills),
            has_prior_year=prior_year is not None,
        )

        return context


    __all__ = [
        "AgentContext",
        "build_agent_context",
        "get_skills_for_task_type",
        "load_skill_for_year",
        "get_client_documents",
        "get_prior_year_return",
        "TASK_TYPE_SKILLS",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.context.builder import AgentContext, build_agent_context"` succeeds
    - Context builder assembles profile, documents, and skills
  </verify>
  <done>Context builder exists with AgentContext dataclass and assembly function</done>
</task>

<task type="auto">
  <name>Task 3: Update context __init__.py with exports</name>
  <files>src/context/__init__.py</files>
  <action>
    Update src/context/__init__.py:

    ```python
    """Context module for client profile and agent context assembly.

    Provides:
    - Profile service: Computed views from append-only log
    - Context builder: Assembles profile + documents + skills for agents
    """

    from src.context.builder import (
        TASK_TYPE_SKILLS,
        AgentContext,
        build_agent_context,
        get_client_documents,
        get_prior_year_return,
        get_skills_for_task_type,
        load_skill_for_year,
    )
    from src.context.profile import (
        append_profile_entry,
        get_client_profile_view,
        get_client_with_profile,
        get_profile_history,
        profile_entry_count,
    )

    __all__ = [
        # Profile service
        "get_client_profile_view",
        "append_profile_entry",
        "get_profile_history",
        "get_client_with_profile",
        "profile_entry_count",
        # Context builder
        "AgentContext",
        "build_agent_context",
        "get_skills_for_task_type",
        "load_skill_for_year",
        "get_client_documents",
        "get_prior_year_return",
        "TASK_TYPE_SKILLS",
    ]
    ```
  </action>
  <verify>
    - `python -c "from src.context import AgentContext, get_client_profile_view, build_agent_context"` succeeds
  </verify>
  <done>Context module exports all profile and builder functions</done>
</task>

<task type="auto">
  <name>Task 4: Create profile service tests</name>
  <files>tests/context/__init__.py, tests/context/test_profile.py</files>
  <action>
    1. Create tests/context/__init__.py (empty)

    2. Create tests/context/test_profile.py:

    ```python
    """Tests for client profile service.

    These tests require database access via pytest fixtures.
    """

    from datetime import datetime
    from typing import AsyncGenerator
    from unittest.mock import AsyncMock, MagicMock, patch

    import pytest
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.context.profile import (
        append_profile_entry,
        get_client_profile_view,
        get_profile_history,
        profile_entry_count,
    )
    from src.models.client import Client, ClientProfileEntry


    class TestGetClientProfileView:
        """Tests for get_client_profile_view function."""

        @pytest.mark.asyncio
        async def test_computes_latest_entry_per_type(self) -> None:
            """Returns latest entry for each entry_type."""
            # Create mock session that returns test data
            mock_session = AsyncMock(spec=AsyncSession)

            # Mock result with multiple entries, only latest per type returned
            mock_result = MagicMock()
            mock_result.fetchall.return_value = [
                ("income_sources", {"w2": True}),
                ("filing_status", {"status": "single"}),
            ]
            mock_session.execute.return_value = mock_result

            profile = await get_client_profile_view(mock_session, client_id=1)

            assert "income_sources" in profile
            assert profile["income_sources"] == {"w2": True}
            assert "filing_status" in profile
            assert profile["filing_status"] == {"status": "single"}

        @pytest.mark.asyncio
        async def test_returns_empty_dict_for_no_entries(self) -> None:
            """Returns empty dict when client has no profile entries."""
            mock_session = AsyncMock(spec=AsyncSession)
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            profile = await get_client_profile_view(mock_session, client_id=999)

            assert profile == {}


    class TestAppendProfileEntry:
        """Tests for append_profile_entry function."""

        @pytest.mark.asyncio
        async def test_creates_new_entry(self) -> None:
            """Creates a new profile entry."""
            mock_session = AsyncMock(spec=AsyncSession)

            # Track what gets added
            added_entries: list[ClientProfileEntry] = []

            def track_add(entry: ClientProfileEntry) -> None:
                entry.id = 1  # Simulate ID assignment
                added_entries.append(entry)

            mock_session.add.side_effect = track_add

            entry = await append_profile_entry(
                mock_session,
                client_id=1,
                entry_type="income_sources",
                data={"w2": True, "self_employment": False},
            )

            assert len(added_entries) == 1
            assert added_entries[0].client_id == 1
            assert added_entries[0].entry_type == "income_sources"
            assert added_entries[0].data == {"w2": True, "self_employment": False}
            mock_session.flush.assert_called_once()

        @pytest.mark.asyncio
        async def test_never_updates_existing(self) -> None:
            """Verify function creates new entry, doesn't update."""
            mock_session = AsyncMock(spec=AsyncSession)
            added_entries: list[ClientProfileEntry] = []

            def track_add(entry: ClientProfileEntry) -> None:
                entry.id = len(added_entries) + 1
                added_entries.append(entry)

            mock_session.add.side_effect = track_add

            # Add same entry type twice
            await append_profile_entry(
                mock_session, client_id=1, entry_type="status", data={"v": 1}
            )
            await append_profile_entry(
                mock_session, client_id=1, entry_type="status", data={"v": 2}
            )

            # Should have TWO entries, not one updated entry
            assert len(added_entries) == 2
            assert added_entries[0].data == {"v": 1}
            assert added_entries[1].data == {"v": 2}


    class TestGetProfileHistory:
        """Tests for get_profile_history function."""

        @pytest.mark.asyncio
        async def test_returns_entries_most_recent_first(self) -> None:
            """Returns entries ordered by created_at descending."""
            mock_session = AsyncMock(spec=AsyncSession)

            # Create mock entries
            entries = [
                MagicMock(
                    entry_type="status",
                    data={"v": 2},
                    created_at=datetime(2024, 2, 1),
                ),
                MagicMock(
                    entry_type="status",
                    data={"v": 1},
                    created_at=datetime(2024, 1, 1),
                ),
            ]

            mock_result = MagicMock()
            mock_result.scalars.return_value.all.return_value = entries
            mock_session.execute.return_value = mock_result

            history = await get_profile_history(mock_session, client_id=1)

            assert len(history) == 2
            # Most recent first
            assert history[0].data == {"v": 2}
            assert history[1].data == {"v": 1}


    class TestProfileEntryCount:
        """Tests for profile_entry_count function."""

        @pytest.mark.asyncio
        async def test_returns_count(self) -> None:
            """Returns total entry count."""
            mock_session = AsyncMock(spec=AsyncSession)
            mock_result = MagicMock()
            mock_result.scalar.return_value = 42
            mock_session.execute.return_value = mock_result

            count = await profile_entry_count(mock_session, client_id=1)

            assert count == 42

        @pytest.mark.asyncio
        async def test_returns_zero_for_no_entries(self) -> None:
            """Returns 0 when no entries exist."""
            mock_session = AsyncMock(spec=AsyncSession)
            mock_result = MagicMock()
            mock_result.scalar.return_value = None  # COUNT returns None for no rows
            mock_session.execute.return_value = mock_result

            count = await profile_entry_count(mock_session, client_id=999)

            assert count == 0
    ```
  </action>
  <verify>
    - `pytest tests/context/test_profile.py -v` passes all tests
    - Tests verify computed view logic and append-only pattern
  </verify>
  <done>Profile service tests pass, verifying append-only pattern</done>
</task>

<task type="auto">
  <name>Task 5: Create context builder tests</name>
  <files>tests/context/test_builder.py</files>
  <action>
    Create tests/context/test_builder.py:

    ```python
    """Tests for context builder."""

    from datetime import date
    from unittest.mock import AsyncMock, MagicMock, patch

    import pytest
    from sqlalchemy.ext.asyncio import AsyncSession

    from src.context.builder import (
        AgentContext,
        build_agent_context,
        get_skills_for_task_type,
    )
    from src.models.client import Client


    class TestAgentContext:
        """Tests for AgentContext dataclass."""

        def test_to_prompt_context_formats_correctly(self) -> None:
            """to_prompt_context produces readable format."""
            context = AgentContext(
                client_id=1,
                client_name="Test Client",
                tax_year=2024,
                task_type="personal_tax",
                client_profile={
                    "income_sources": {"w2": True, "self_employment": False},
                    "filing_status": {"status": "single"},
                },
                documents=[
                    {"type": "W-2", "content": {"employer": "Acme", "wages": 50000}},
                ],
                skills=["Process W-2 forms by extracting..."],
            )

            prompt = context.to_prompt_context()

            assert "Test Client" in prompt
            assert "2024" in prompt
            assert "income_sources" in prompt
            assert "W-2" in prompt

        def test_to_prompt_context_handles_empty(self) -> None:
            """to_prompt_context handles empty context."""
            context = AgentContext(
                client_id=1,
                client_name="Empty Client",
                tax_year=2024,
                task_type="personal_tax",
            )

            prompt = context.to_prompt_context()

            assert "Empty Client" in prompt
            assert "2024" in prompt


    class TestGetSkillsForTaskType:
        """Tests for get_skills_for_task_type function."""

        def test_returns_personal_tax_skills(self) -> None:
            """Returns correct skills for personal_tax."""
            skills = get_skills_for_task_type("personal_tax")

            assert "personal_tax_w2" in skills
            assert len(skills) > 0

        def test_returns_business_tax_skills(self) -> None:
            """Returns correct skills for business_tax."""
            skills = get_skills_for_task_type("business_tax")

            assert "business_tax_1120s" in skills

        def test_returns_empty_for_unknown_type(self) -> None:
            """Returns empty list for unknown task type."""
            skills = get_skills_for_task_type("unknown_type")

            assert skills == []


    class TestBuildAgentContext:
        """Tests for build_agent_context function."""

        @pytest.mark.asyncio
        async def test_builds_context_with_profile(self) -> None:
            """Builds context with client profile."""
            mock_session = AsyncMock(spec=AsyncSession)

            # Mock client query
            mock_client = MagicMock(spec=Client)
            mock_client.id = 1
            mock_client.name = "Test Client"

            client_result = MagicMock()
            client_result.scalar_one_or_none.return_value = mock_client

            # Mock profile query
            profile_result = MagicMock()
            profile_result.fetchall.return_value = [
                ("income_sources", {"w2": True}),
            ]

            # Mock skills query (empty for now)
            skills_result = MagicMock()
            skills_result.scalars.return_value.all.return_value = []

            # Configure mock to return different results for different queries
            mock_session.execute.side_effect = [
                client_result,  # Client query
                profile_result,  # Profile query
            ]

            with patch(
                "src.context.builder.get_client_documents",
                return_value=[],
            ), patch(
                "src.context.builder.get_prior_year_return",
                return_value=None,
            ), patch(
                "src.context.builder.load_skill_for_year",
                return_value=None,
            ):
                context = await build_agent_context(
                    mock_session,
                    client_id=1,
                    task_type="personal_tax",
                    tax_year=2024,
                )

            assert context.client_id == 1
            assert context.client_name == "Test Client"
            assert context.tax_year == 2024
            assert context.task_type == "personal_tax"
            assert "income_sources" in context.client_profile

        @pytest.mark.asyncio
        async def test_raises_for_nonexistent_client(self) -> None:
            """Raises ValueError for nonexistent client."""
            mock_session = AsyncMock(spec=AsyncSession)

            # Mock client query returning None
            client_result = MagicMock()
            client_result.scalar_one_or_none.return_value = None
            mock_session.execute.return_value = client_result

            with pytest.raises(ValueError) as exc_info:
                await build_agent_context(
                    mock_session,
                    client_id=999,
                    task_type="personal_tax",
                    tax_year=2024,
                )

            assert "Client not found" in str(exc_info.value)

        @pytest.mark.asyncio
        async def test_assembles_all_components(self) -> None:
            """Verifies all context components are assembled."""
            mock_session = AsyncMock(spec=AsyncSession)

            # Mock client
            mock_client = MagicMock(spec=Client)
            mock_client.id = 1
            mock_client.name = "Full Context Client"

            client_result = MagicMock()
            client_result.scalar_one_or_none.return_value = mock_client

            # Mock profile
            profile_result = MagicMock()
            profile_result.fetchall.return_value = [
                ("status", {"filing": "single"}),
            ]

            mock_session.execute.side_effect = [
                client_result,
                profile_result,
            ]

            # Mock other functions
            mock_docs = [{"type": "W-2", "content": {"wages": 50000}}]
            mock_prior = {"agi": 48000}

            with patch(
                "src.context.builder.get_client_documents",
                return_value=mock_docs,
            ), patch(
                "src.context.builder.get_prior_year_return",
                return_value=mock_prior,
            ), patch(
                "src.context.builder.load_skill_for_year",
                return_value=MagicMock(instructions="Test skill"),
            ):
                context = await build_agent_context(
                    mock_session,
                    client_id=1,
                    task_type="personal_tax",
                    tax_year=2024,
                )

            # Verify all components present
            assert context.client_profile == {"status": {"filing": "single"}}
            assert context.documents == mock_docs
            assert len(context.skills) > 0  # Skills were loaded
            assert context.prior_year_return == mock_prior
    ```
  </action>
  <verify>
    - `pytest tests/context/test_builder.py -v` passes all tests
    - Tests verify context assembly with profile, documents, skills
  </verify>
  <done>Context builder tests pass, verifying assembly logic</done>
</task>

</tasks>

<verification>
1. `python -c "from src.context import AgentContext, get_client_profile_view, build_agent_context"` imports successfully
2. `pytest tests/context/ -v` passes all tests
3. Profile computed view uses window functions to get latest entry per type
4. append_profile_entry creates new entries (never updates)
5. Context builder assembles profile + documents + skills
</verification>

<success_criteria>
- Profile computed view returns latest entry per entry_type
- append_profile_entry creates new entries (append-only pattern enforced)
- AgentContext dataclass contains all necessary fields
- build_agent_context assembles complete context for agents
- All tests pass with full coverage
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-framework/02-05-SUMMARY.md`
</output>
