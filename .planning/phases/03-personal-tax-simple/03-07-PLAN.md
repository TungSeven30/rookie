---
phase: 03-personal-tax-simple
plan: 07
type: execute
wave: 6
depends_on: ["03-02", "03-04", "03-05", "03-06"]
files_modified:
  - src/agents/personal_tax/agent.py
autonomous: true

must_haves:
  truths:
    - "Agent loads client profile before processing"
    - "Agent scans client folder for documents"
    - "Agent extracts data from all discovered documents"
    - "Agent aggregates income and calculates tax"
    - "Agent generates Drake worksheet and preparer notes"
    - "Agent escalates when required documents are missing"
    - "Agent escalates on conflicting information"
  artifacts:
    - path: "src/agents/personal_tax/agent.py"
      provides: "Personal Tax Agent orchestration"
      exports: ["PersonalTaxAgent", "personal_tax_handler"]
      min_lines: 150
  key_links:
    - from: "src/agents/personal_tax/agent.py"
      to: "src/context/builder.py"
      via: "Context loading"
      pattern: "build_agent_context"
    - from: "src/agents/personal_tax/agent.py"
      to: "src/documents/scanner.py"
      via: "Document discovery"
      pattern: "scan_client_folder"
    - from: "src/agents/personal_tax/agent.py"
      to: "src/documents/extractor.py"
      via: "Document extraction"
      pattern: "extract_document"
    - from: "src/agents/personal_tax/agent.py"
      to: "src/agents/personal_tax/calculator.py"
      via: "Tax calculations"
      pattern: "aggregate_income|calculate_tax"
    - from: "src/agents/personal_tax/agent.py"
      to: "src/agents/personal_tax/output.py"
      via: "Output generation"
      pattern: "generate_drake_worksheet|generate_preparer_notes"
---

<objective>
Create Personal Tax Agent that orchestrates the complete tax preparation workflow.

Purpose: This is the main agent entry point that coordinates document scanning, extraction, calculation, and output generation. Required for PTAX-01 (load profile), PTAX-02 (scan folder), PTAX-15 (escalate missing), PTAX-16 (escalate conflicts).

Output:
- src/agents/personal_tax/agent.py with PersonalTaxAgent class and handler function
</objective>

<execution_context>
@/Users/tungmbp1423/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tungmbp1423/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-personal-tax-simple/03-RESEARCH.md
@src/context/builder.py
@src/documents/scanner.py
@src/documents/extractor.py
@src/agents/personal_tax/calculator.py
@src/agents/personal_tax/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Personal Tax Agent class</name>
  <files>src/agents/personal_tax/agent.py</files>
  <action>
Create agent.py with PersonalTaxAgent class orchestrating the workflow.

**PersonalTaxResult dataclass:**
```python
@dataclass
class PersonalTaxResult:
    """Result of personal tax agent execution."""
    drake_worksheet_path: Path
    preparer_notes_path: Path
    income_summary: IncomeSummary
    tax_result: TaxResult
    variances: list[VarianceItem]
    extractions: list[dict]  # [{type, filename, confidence}]
    escalations: list[str]
    overall_confidence: str  # HIGH/MEDIUM/LOW
```

**PersonalTaxAgent class:**
```python
class PersonalTaxAgent:
    """Personal Tax Agent for simple returns (W-2, 1099-INT/DIV/NEC).

    Workflow:
    1. Load client context (profile, prior year)
    2. Scan client folder for documents
    3. Classify and extract each document
    4. Check for missing expected documents
    5. Aggregate income
    6. Calculate deductions and tax
    7. Compare with prior year
    8. Generate outputs
    9. Handle escalations
    """

    def __init__(
        self,
        storage_url: str,
        output_dir: Path,
    ):
        self.storage_url = storage_url
        self.output_dir = output_dir
        self.escalations: list[str] = []

    async def process(
        self,
        client_id: str,
        tax_year: int,
        session: AsyncSession,
        filing_status: str = "single",
    ) -> PersonalTaxResult:
        """Process personal tax return.

        Args:
            client_id: Client identifier
            tax_year: Tax year to process
            session: Database session
            filing_status: Filing status for deductions/brackets

        Returns:
            PersonalTaxResult with all outputs

        Raises:
            EscalationRequired: If missing documents or conflicts require human attention
        """
```

**Implementation steps in process():**

1. **Load context (PTAX-01):**
```python
context = await build_agent_context(
    session=session,
    client_id=client_id,
    task_type="personal_tax",
    tax_year=tax_year,
)
```

2. **Scan for documents (PTAX-02):**
```python
documents = scan_client_folder(
    self.storage_url,
    client_id,
    tax_year,
)
if not documents:
    self.escalations.append("No documents found in client folder")
    raise EscalationRequired(self.escalations)
```

3. **Classify and extract each document:**
```python
extractions = []
for doc in documents:
    image_bytes = await read_file(self.storage_url, doc.path)
    classification = await classify_document(image_bytes, ...)
    if classification.document_type != DocumentType.UNKNOWN:
        data = await extract_document(image_bytes, classification.document_type, ...)
        extractions.append({
            "type": classification.document_type,
            "filename": doc.name,
            "confidence": data.confidence,
            "data": data,
        })
```

4. **Check for missing documents (PTAX-15):**
```python
expected_types = self._get_expected_document_types(context.prior_year_return)
found_types = {e["type"] for e in extractions}
missing = expected_types - found_types
if missing:
    for doc_type in missing:
        self.escalations.append(f"Missing expected document: {doc_type.value}")
```

5. **Check for conflicts (PTAX-16):**
```python
conflicts = self._check_conflicts(extractions)
if conflicts:
    for conflict in conflicts:
        self.escalations.append(f"Conflicting information: {conflict}")
```

6. **Aggregate and calculate:**
```python
income_summary = aggregate_income([e["data"] for e in extractions])
deduction_result = calculate_deductions(income_summary, filing_status, tax_year)
taxable_income = income_summary.total_income - deduction_result.amount
tax_result = calculate_tax(taxable_income, filing_status, tax_year)
```

7. **Compare with prior year (PTAX-12):**
```python
if context.prior_year_return:
    variances = compare_years(
        {"total_income": income_summary.total_income, ...},
        context.prior_year_return,
    )
```

8. **Generate outputs (PTAX-13, PTAX-14):**
```python
worksheet_path = generate_drake_worksheet(...)
notes_path = generate_preparer_notes(...)
```

9. **Return or escalate:**
```python
if self.escalations:
    raise EscalationRequired(self.escalations)
return PersonalTaxResult(...)
```

**EscalationRequired exception:**
```python
class EscalationRequired(Exception):
    """Raised when agent needs human intervention."""
    def __init__(self, reasons: list[str]):
        self.reasons = reasons
        super().__init__(f"Escalation required: {', '.join(reasons)}")
```

**Helper methods:**
- `_get_expected_document_types(prior_year)` - Returns set of DocumentType expected based on prior year
- `_check_conflicts(extractions)` - Checks for conflicting SSN, EIN, etc. across documents
- `_determine_overall_confidence(extractions)` - Returns HIGH if all HIGH, MEDIUM if any MEDIUM, LOW if any LOW
  </action>
  <verify>
```bash
uv run python -c "
from src.agents.personal_tax.agent import PersonalTaxAgent, PersonalTaxResult, EscalationRequired
from pathlib import Path

agent = PersonalTaxAgent(
    storage_url='/tmp/test',
    output_dir=Path('/tmp/output')
)
print(f'Agent created: {agent}')
print('PersonalTaxAgent class OK')
"
```
  </verify>
  <done>PersonalTaxAgent class created with process() method orchestrating full workflow</done>
</task>

<task type="auto">
  <name>Task 2: Create task handler function</name>
  <files>src/agents/personal_tax/agent.py</files>
  <action>
Add task handler function that integrates with the task dispatcher.

**personal_tax_handler function:**
```python
async def personal_tax_handler(task: Task, session: AsyncSession) -> None:
    """Handle personal tax task from dispatcher.

    This function is registered with TaskDispatcher for task_type="personal_tax".

    Args:
        task: Task to process
        session: Database session

    Side effects:
        - Updates task status (completed/failed/escalated)
        - Creates TaskArtifact entries for outputs
        - Creates Escalation entries if needed
    """
```

**Implementation:**
```python
async def personal_tax_handler(task: Task, session: AsyncSession) -> None:
    from src.core.config import get_settings
    from src.models.task import TaskArtifact, Escalation

    settings = get_settings()

    # Get storage URL from task metadata or settings
    storage_url = task.metadata.get("storage_url", settings.default_storage_url)
    output_dir = Path(settings.output_dir) / str(task.client_id) / str(task.tax_year)
    output_dir.mkdir(parents=True, exist_ok=True)

    agent = PersonalTaxAgent(
        storage_url=storage_url,
        output_dir=output_dir,
    )

    try:
        result = await agent.process(
            client_id=str(task.client_id),
            tax_year=task.tax_year,
            session=session,
            filing_status=task.metadata.get("filing_status", "single"),
        )

        # Create artifacts
        session.add(TaskArtifact(
            task_id=task.id,
            artifact_type="drake_worksheet",
            file_path=str(result.drake_worksheet_path),
            metadata={"confidence": result.overall_confidence},
        ))
        session.add(TaskArtifact(
            task_id=task.id,
            artifact_type="preparer_notes",
            file_path=str(result.preparer_notes_path),
            metadata={},
        ))

        # Task completed
        task.status = TaskStatus.COMPLETED
        task.completed_at = datetime.utcnow()

    except EscalationRequired as e:
        # Create escalation
        escalation = Escalation(
            task_id=task.id,
            reason="; ".join(e.reasons),
            created_at=datetime.utcnow(),
        )
        session.add(escalation)
        task.status = TaskStatus.ESCALATED

    except Exception as e:
        # Task failed
        task.status = TaskStatus.FAILED
        task.error_message = str(e)

    await session.commit()
```

Update src/agents/personal_tax/__init__.py to export handler and agent.
  </action>
  <verify>
```bash
uv run python -c "
from src.agents.personal_tax import personal_tax_handler, PersonalTaxAgent, EscalationRequired
print('Handler and exports OK')
"
```
  </verify>
  <done>personal_tax_handler created for dispatcher integration</done>
</task>

<task type="auto">
  <name>Task 3: Create agent tests</name>
  <files>tests/agents/personal_tax/test_agent.py</files>
  <action>
Create tests for PersonalTaxAgent and handler.

**test_agent.py tests:**

**Unit tests (mock dependencies):**
- test_agent_init -> agent initializes with storage_url and output_dir
- test_agent_escalates_no_documents -> EscalationRequired when no documents
- test_agent_escalates_missing_expected -> EscalationRequired when prior year doc missing
- test_agent_escalates_conflicts -> EscalationRequired on SSN mismatch
- test_determine_confidence_all_high -> returns HIGH
- test_determine_confidence_any_medium -> returns MEDIUM
- test_determine_confidence_any_low -> returns LOW
- test_get_expected_types_from_prior -> returns correct types from prior year

**Integration tests (mock LLM, real logic):**
- test_agent_process_single_w2 -> processes one W-2 successfully
- test_agent_process_multiple_documents -> handles mixed documents
- test_agent_generates_outputs -> worksheet and notes created
- test_agent_compares_prior_year -> variances detected

**Handler tests:**
- test_handler_completes_task -> task status set to COMPLETED
- test_handler_creates_artifacts -> TaskArtifact entries created
- test_handler_escalates_task -> task status set to ESCALATED
- test_handler_fails_on_error -> task status set to FAILED

Use pytest fixtures with mocks for:
- scan_client_folder (return test documents)
- classify_document (return mock classification)
- extract_document (return mock data)
- build_agent_context (return mock context)

Set MOCK_LLM=true for all tests.
  </action>
  <verify>
```bash
MOCK_LLM=true uv run pytest tests/agents/personal_tax/test_agent.py -v
```
All tests pass.
  </verify>
  <done>20+ tests covering agent orchestration and handler pass</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Agent importable:
```bash
uv run python -c "from src.agents.personal_tax import PersonalTaxAgent, personal_tax_handler, EscalationRequired; print('Agent OK')"
```

2. All tests pass:
```bash
MOCK_LLM=true uv run pytest tests/agents/personal_tax/ -v
```

3. Full module test:
```bash
uv run pytest tests/agents/ -v
```
</verification>

<success_criteria>
- PersonalTaxAgent orchestrates complete workflow
- Agent loads context before processing (PTAX-01)
- Agent scans folder for documents (PTAX-02)
- Agent escalates on missing documents (PTAX-15)
- Agent escalates on conflicts (PTAX-16)
- Handler integrates with task dispatcher pattern
- 20+ unit/integration tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-personal-tax-simple/03-07-SUMMARY.md`
</output>
