# Plan 04-02: K-1 and 1099-B Extractors

---
phase: 04-personal-tax-complex
plan: 02
type: execute
wave: 1
depends_on: ["04-01"]
---

## Objective

Create Vision API extraction prompts and functions for K-1 and 1099-B documents.

**Purpose:** Enable automated extraction of K-1 and 1099-B data from scanned documents using the same pattern established in Phase 3.

**Output:**
- FORM_K1_PROMPT for extraction
- FORM_1099_B_PROMPT for extraction
- extract_k1() function
- extract_1099_b() function
- Mock functions for testing

## Tasks

### Task 1: Create K-1 Extraction Prompt

**Files:** src/documents/prompts.py

**Action:**
Create FORM_K1_PROMPT with detailed field mappings:

```python
FORM_K1_PROMPT = """
You are extracting data from a Schedule K-1 (Form 1065 or Form 1120-S).
Return a JSON object with the following fields:

PART I - ENTITY INFORMATION:
- entity_name: Name of partnership or S-corporation
- entity_ein: Entity's Employer Identification Number (XX-XXXXXXX format)
- entity_type: "partnership" (Form 1065) or "s_corp" (Form 1120-S)
- tax_year: The tax year this K-1 is for (YYYY format)

PART II - PARTNER/SHAREHOLDER INFORMATION:
- recipient_name: Partner or shareholder name
- recipient_tin: Partner/shareholder's TIN (SSN or EIN)
- ownership_percentage: Percentage of ownership (as decimal, e.g., 25.5 for 25.5%)

PART III - SHARE OF INCOME, DEDUCTIONS, CREDITS:
- ordinary_business_income: Box 1 - Ordinary business income (loss)
- net_rental_real_estate: Box 2 - Net rental real estate income (loss)
- other_rental_income: Box 3 - Other net rental income (loss)
- guaranteed_payments: Box 4 - Guaranteed payments (partnerships only)
- interest_income: Box 5 - Interest income
- dividend_income: Box 6a/6b - Dividends (total amount)
- royalties: Box 7 - Royalties
- net_short_term_capital_gain: Box 8 - Net short-term capital gain (loss)
- net_long_term_capital_gain: Box 9a - Net long-term capital gain (loss)
- net_section_1231_gain: Box 10 - Net section 1231 gain (loss)
- other_income: Box 11 - Other income (loss) - sum of all codes
- section_179_deduction: Box 12 - Section 179 deduction
- other_deductions: Box 13 - Other deductions - sum of all codes
- self_employment_earnings: Box 14 - Self-employment earnings (loss)
- credits: Box 15 - Credits (total of all credit types)
- foreign_transactions: Box 16 - Foreign transactions (total amount)
- distributions: Box 19 - Distributions

For all amounts:
- Use negative numbers for losses
- Enter 0 if box is blank or not applicable
- Look for totals, not individual codes within boxes

Return JSON format exactly matching the field names above.
Also return:
- uncertain_fields: Array of field names with low confidence
"""
```

**Verify:**
```bash
uv run python -c "
from src.documents.prompts import FORM_K1_PROMPT
assert 'ordinary_business_income' in FORM_K1_PROMPT
assert 'Box 1' in FORM_K1_PROMPT
print('K-1 prompt ready')
"
```

**Done:** FORM_K1_PROMPT created with all box mappings

---

### Task 2: Create 1099-B Extraction Prompt

**Files:** src/documents/prompts.py

**Action:**
Create FORM_1099_B_PROMPT:

```python
FORM_1099_B_PROMPT = """
You are extracting data from a Form 1099-B (Proceeds from Broker Transactions).
This form may have one or multiple transactions. Extract each transaction separately.

For EACH transaction, extract:

PAYER INFORMATION:
- payer_name: Broker/financial institution name
- payer_tin: Broker's TIN (EIN)
- account_number: Account number (if shown)

RECIPIENT:
- recipient_tin: Recipient's SSN or TIN

TRANSACTION DETAILS:
- description: Box 1a - Description of property (stock name, CUSIP, etc.)
- date_acquired: Box 1b - Date acquired (YYYY-MM-DD or "Various")
- date_sold: Box 1c - Date sold or disposed (YYYY-MM-DD)
- proceeds: Box 1d - Proceeds (gross amount)
- cost_basis: Box 1e - Cost or other basis (may be blank if not reported to IRS)
- wash_sale_loss_disallowed: Box 1g - Wash sale loss disallowed
- gain_loss: Box 1h - Gain or loss (if reported)

CLASSIFICATION:
- is_short_term: True if Box 2 is checked (held 1 year or less)
- is_long_term: True if Box 3 is checked (held more than 1 year)
- basis_reported_to_irs: True if Box 12 is checked

SPECIAL:
- is_collectibles: True if this is a collectibles transaction
- is_qof: True if this is a Qualified Opportunity Fund investment

For each transaction on the form, return a separate object in a JSON array.
If the form shows summary/totals, ignore those and extract individual transactions.

Return:
- transactions: Array of transaction objects, each with:
  - All fields above
  - uncertain_fields: Array of field names with low confidence FOR THIS TRANSACTION
- form_level_uncertain_fields: Array of fields uncertain at the form level (payer_name, etc.)

NOTE: Track uncertainty per-transaction using "uncertain_fields" (matching the Form1099B model field name).
"""
```

**Verify:**
```bash
uv run python -c "
from src.documents.prompts import FORM_1099_B_PROMPT
assert 'proceeds' in FORM_1099_B_PROMPT
assert 'Box 1d' in FORM_1099_B_PROMPT
print('1099-B prompt ready')
"
```

**Done:** FORM_1099_B_PROMPT created for transaction extraction

---

### Task 3: Implement extract_k1() Function

**Files:** src/documents/extractor.py

**Action:**
Create extract_k1() using established pattern:

```python
async def extract_k1(
    client: anthropic.AsyncAnthropic,
    image_data: bytes,
    mock: bool = False,
) -> FormK1:
    """
    Extract Schedule K-1 data from image.
    
    Args:
        client: Anthropic API client
        image_data: Document image bytes
        mock: Use mock extraction for testing
        
    Returns:
        FormK1 model with extracted data
        
    Raises:
        ExtractionError: If extraction fails
    """
    if mock:
        return _mock_k1()
    
    response = await _extract_with_vision(
        client=client,
        image_data=image_data,
        prompt=FORM_K1_PROMPT,
        response_model=FormK1,
    )
    
    return response
```

**Verify:**
```bash
uv run python -c "
import asyncio
from src.documents.extractor import extract_k1

async def test():
    result = await extract_k1(None, b'', mock=True)
    print(f'Mock K-1: {result.entity_name}, income={result.ordinary_business_income}')

asyncio.run(test())
"
```

**Done:** extract_k1() function implemented

---

### Task 4: Implement extract_1099_b() Function

**Files:** src/documents/extractor.py

**Action:**
Create extract_1099_b() that returns multiple transactions:

```python
async def extract_1099_b(
    client: anthropic.AsyncAnthropic,
    image_data: bytes,
    mock: bool = False,
) -> list[Form1099B]:
    """
    Extract Form 1099-B transactions from image.
    
    A single 1099-B form may contain multiple transactions.
    
    Args:
        client: Anthropic API client
        image_data: Document image bytes
        mock: Use mock extraction for testing
        
    Returns:
        List of Form1099B models for each transaction
        
    Raises:
        ExtractionError: If extraction fails
    """
    if mock:
        return _mock_1099_b()
    
    # Custom extraction for multi-transaction form
    response = await _extract_with_vision(
        client=client,
        image_data=image_data,
        prompt=FORM_1099_B_PROMPT,
        response_model=Form1099BExtraction,  # Wrapper model
    )
    
    return response.transactions
```

Create wrapper model for extraction:

```python
class Form1099BExtraction(BaseModel):
    """Wrapper for 1099-B multi-transaction extraction."""
    transactions: list[Form1099B]
    form_level_uncertain_fields: list[str] = Field(default_factory=list)

# NOTE: Each Form1099B should have its own uncertain_fields
# to track per-transaction uncertainty (e.g., cost_basis missing on one transaction)
```

**Verify:**
```bash
uv run python -c "
import asyncio
from src.documents.extractor import extract_1099_b

async def test():
    results = await extract_1099_b(None, b'', mock=True)
    print(f'Mock 1099-Bs: {len(results)} transactions')
    for t in results:
        print(f'  - {t.description}: proceeds={t.proceeds}')

asyncio.run(test())
"
```

**Done:** extract_1099_b() function returns list of transactions

---

### Task 4b: Implement Smart 1099-B Extraction (High-Volume)

**Files:** src/documents/extractor.py

**Action:**
Create extract_1099_b_smart() that uses summary mode for large statements:

```python
async def extract_1099_b_smart(
    client: anthropic.AsyncAnthropic,
    image_data: bytes,
    mock: bool = False,
) -> Form1099BSummary | list[Form1099B]:
    """
    Smart 1099-B extraction that uses summary mode for large statements.
    
    Strategy:
    1. First pass: Ask LLM how many transactions are on the form
    2. If <50 transactions: Extract individually (original behavior)
    3. If >=50 transactions: Extract summary totals by category
    
    This prevents API cost explosion and reduces extraction errors
    on high-volume broker statements.
    
    Returns:
        Form1099BSummary for high-volume (50+), list[Form1099B] otherwise
    """
    if mock:
        return _mock_1099_b()
    
    # First: Quick count check with fast model
    count_response = await client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=50,
        messages=[{
            "role": "user",
            "content": [
                {
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": "image/png",
                        "data": base64.b64encode(image_data).decode()
                    }
                },
                {
                    "type": "text",
                    "text": "How many individual stock/security transactions are listed "
                            "on this 1099-B form? Just respond with a number."
                }
            ]
        }]
    )
    
    try:
        transaction_count = int(count_response.content[0].text.strip())
    except (ValueError, IndexError):
        transaction_count = 1  # Assume small if unclear
    
    if transaction_count >= 50:
        # Use summary extraction for high-volume statements
        return await _extract_1099_b_summary(client, image_data)
    else:
        # Use detailed extraction for manageable transaction counts
        return await extract_1099_b(client, image_data, mock=False)


FORM_1099_B_SUMMARY_PROMPT = '''
You are extracting SUMMARY TOTALS from a Form 1099-B broker statement.
This statement has many transactions - extract category totals, not individual transactions.

Extract the following category summaries (matching IRS Form 8949):

CATEGORY A - Short-Term, Basis Reported to IRS:
- cat_a_proceeds: Total proceeds (sales price)
- cat_a_cost_basis: Total cost basis
- cat_a_adjustments: Total adjustments (wash sales, etc.)
- cat_a_gain_loss: Total gain/loss
- cat_a_transaction_count: Number of transactions in this category

CATEGORY B - Short-Term, Basis NOT Reported to IRS:
- cat_b_proceeds: Total proceeds
- cat_b_cost_basis: Total cost basis (if shown, else null)
- cat_b_transaction_count: Number of transactions

CATEGORY D - Long-Term, Basis Reported to IRS:
- cat_d_proceeds: Total proceeds
- cat_d_cost_basis: Total cost basis
- cat_d_adjustments: Total adjustments
- cat_d_gain_loss: Total gain/loss
- cat_d_transaction_count: Number of transactions

CATEGORY E - Long-Term, Basis NOT Reported to IRS:
- cat_e_proceeds: Total proceeds
- cat_e_cost_basis: Total cost basis (if shown, else null)
- cat_e_transaction_count: Number of transactions

Also extract:
- total_wash_sale_disallowed: Total wash sale loss disallowed
- total_transaction_count: Total number of all transactions
- payer_name, payer_tin, recipient_tin

Return JSON matching the Form1099BSummary model.
'''


async def _extract_1099_b_summary(
    client: anthropic.AsyncAnthropic,
    image_data: bytes,
) -> Form1099BSummary:
    """Extract category summary totals from high-volume 1099-B."""
    response = await _extract_with_vision(
        client=client,
        image_data=image_data,
        prompt=FORM_1099_B_SUMMARY_PROMPT,
        response_model=Form1099BSummary,
    )
    return response
```

**Verify:**
```bash
uv run python -c "
# Note: Full test requires actual API call with multi-page broker statement
print('Smart 1099-B extraction: Use summary mode when transaction_count >= 50')
print('Categories: A (ST reported), B (ST not reported), D (LT reported), E (LT not reported)')
"
```

**Done:** Smart 1099-B extraction with threshold-based summary mode

---

### Task 5: Create Mock Functions

**Files:** src/documents/extractor.py

**Action:**
Create mock functions for testing:

```python
def _mock_k1() -> FormK1:
    """Return mock K-1 for testing."""
    return FormK1(
        entity_name="Demo Partnership LLC",
        entity_ein="12-3456789",
        entity_type="partnership",
        tax_year=2024,
        recipient_name="John Q. Taxpayer",
        recipient_tin="123-45-6789",
        ownership_percentage=Decimal("25.0"),
        ordinary_business_income=Decimal("45000"),
        guaranteed_payments=Decimal("12000"),
        interest_income=Decimal("500"),
        dividend_income=Decimal("1200"),
        net_long_term_capital_gain=Decimal("3500"),
        distributions=Decimal("15000"),
        self_employment_earnings=Decimal("57000"),
        confidence=ConfidenceLevel.HIGH,
    )


def _mock_1099_b() -> list[Form1099B]:
    """Return mock 1099-B transactions for testing."""
    return [
        Form1099B(
            payer_name="Fidelity Investments",
            payer_tin="12-3456789",
            recipient_tin="123-45-6789",
            account_number="X12345",
            description="AAPL - Apple Inc (100 shares)",
            date_acquired="2023-01-15",
            date_sold="2024-06-20",
            proceeds=Decimal("19500"),
            cost_basis=Decimal("15000"),
            is_long_term=True,
            confidence=ConfidenceLevel.HIGH,
        ),
        Form1099B(
            payer_name="Fidelity Investments",
            payer_tin="12-3456789",
            recipient_tin="123-45-6789",
            account_number="X12345",
            description="MSFT - Microsoft Corp (50 shares)",
            date_acquired="2024-03-01",
            date_sold="2024-09-15",
            proceeds=Decimal("21000"),
            cost_basis=Decimal("18500"),
            is_short_term=True,
            confidence=ConfidenceLevel.HIGH,
        ),
    ]
```

**Verify:**
```bash
uv run python -c "
from src.documents.extractor import _mock_k1, _mock_1099_b
k1 = _mock_k1()
print(f'Mock K-1: {k1.ordinary_business_income}')
b_list = _mock_1099_b()
print(f'Mock 1099-Bs: {len(b_list)} transactions')
"
```

**Done:** Mock functions return realistic test data

---

### Task 6: Update extract_document() Router

**Files:** src/documents/extractor.py

**Action:**
Add new document types to extraction router:

```python
async def extract_document(
    client: anthropic.AsyncAnthropic,
    doc_type: DocumentType,
    image_data: bytes,
    mock: bool = False,
) -> BaseModel:
    """
    Route document extraction based on type.
    """
    extractors = {
        # ... existing extractors ...
        DocumentType.FORM_K1: extract_k1,
        DocumentType.FORM_1099_B: extract_1099_b,
    }
    
    extractor = extractors.get(doc_type)
    if not extractor:
        raise ValueError(f"No extractor for document type: {doc_type}")
    
    return await extractor(client, image_data, mock=mock)
```

**Verify:**
```bash
uv run python -c "
import asyncio
from src.documents.models import DocumentType
from src.documents.extractor import extract_document

async def test():
    result = await extract_document(None, DocumentType.FORM_K1, b'', mock=True)
    print(f'Routed K-1: {result.entity_name}')

asyncio.run(test())
"
```

**Done:** Router handles K-1 and 1099-B extraction

---

### Task 7: Create Extractor Tests

**Files:** tests/documents/test_extractor.py

**Action:**
Add tests for new extractors:

```python
class TestK1Extractor:
    """Tests for K-1 extraction."""
    
    @pytest.mark.asyncio
    async def test_extract_k1_mock(self):
        """K-1 extraction returns valid FormK1 in mock mode."""
        result = await extract_k1(None, b"", mock=True)
        assert isinstance(result, FormK1)
        assert result.entity_type in ["partnership", "s_corp"]
        assert result.ordinary_business_income >= 0
    
    @pytest.mark.asyncio
    async def test_extract_k1_has_required_fields(self):
        """K-1 extraction includes all required fields."""
        result = await extract_k1(None, b"", mock=True)
        assert result.entity_name
        assert result.entity_ein
        assert result.recipient_tin
        assert result.tax_year
    
    @pytest.mark.asyncio
    async def test_extract_k1_confidence(self):
        """K-1 extraction includes confidence level."""
        result = await extract_k1(None, b"", mock=True)
        assert result.confidence in ConfidenceLevel


class TestForm1099BExtractor:
    """Tests for 1099-B extraction."""
    
    @pytest.mark.asyncio
    async def test_extract_1099_b_mock(self):
        """1099-B extraction returns list of transactions."""
        result = await extract_1099_b(None, b"", mock=True)
        assert isinstance(result, list)
        assert len(result) >= 1
        assert all(isinstance(t, Form1099B) for t in result)
    
    @pytest.mark.asyncio
    async def test_extract_1099_b_transaction_fields(self):
        """1099-B transactions have required fields."""
        result = await extract_1099_b(None, b"", mock=True)
        for t in result:
            assert t.payer_name
            assert t.description
            assert t.date_sold
            assert t.proceeds > 0
    
    @pytest.mark.asyncio
    async def test_extract_1099_b_term_classification(self):
        """1099-B transactions have short/long term classification."""
        result = await extract_1099_b(None, b"", mock=True)
        for t in result:
            # At least one should be true, but not both
            assert t.is_short_term != t.is_long_term or (not t.is_short_term and not t.is_long_term)


class TestDocumentRouter:
    """Tests for extract_document router."""
    
    @pytest.mark.asyncio
    async def test_router_k1(self):
        """Router handles K-1 documents."""
        result = await extract_document(None, DocumentType.FORM_K1, b"", mock=True)
        assert isinstance(result, FormK1)
    
    @pytest.mark.asyncio
    async def test_router_1099_b(self):
        """Router handles 1099-B documents."""
        result = await extract_document(None, DocumentType.FORM_1099_B, b"", mock=True)
        assert isinstance(result, list)
```

**Verify:**
```bash
uv run pytest tests/documents/test_extractor.py -v -k "K1 or 1099" --tb=short
```
All tests pass.

**Done:** Extractor tests for K-1 and 1099-B pass

---

### Task 8: Add Document Validation Layer

**Files:** src/documents/validation.py (new)

**Action:**
Create validation layer to catch extraction errors before calculation:

```python
"""Document validation for extracted data."""

from dataclasses import dataclass, field
from decimal import Decimal

from src.documents.models import FormW2, FormK1, Form1099B


@dataclass
class ValidationResult:
    """Result of document validation."""
    is_valid: bool
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    corrections_applied: list[str] = field(default_factory=list)


class DocumentValidator:
    """Validate extracted document data for consistency and accuracy."""
    
    def validate_w2(self, w2: FormW2) -> ValidationResult:
        """Validate W-2 data."""
        errors = []
        warnings = []
        
        # Federal withholding shouldn't exceed wages
        if w2.federal_withholding > w2.wages_tips_compensation:
            errors.append(
                f"Federal withholding ({w2.federal_withholding}) "
                f"exceeds wages ({w2.wages_tips_compensation})"
            )
        
        # Social Security wages have a cap
        ss_cap = Decimal("168600")  # 2024 - should use TaxYearConfig
        if w2.social_security_wages > ss_cap:
            warnings.append(
                f"Social Security wages ({w2.social_security_wages}) "
                f"exceed cap ({ss_cap})"
            )
        
        # SS tax should be ~6.2% of SS wages
        expected_ss_tax = min(w2.social_security_wages, ss_cap) * Decimal("0.062")
        if abs(w2.social_security_tax - expected_ss_tax) > Decimal("10"):
            warnings.append(
                f"Social Security tax ({w2.social_security_tax}) "
                f"doesn't match expected ({expected_ss_tax:.2f})"
            )
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
        )
    
    def validate_k1(self, k1: FormK1) -> ValidationResult:
        """Validate K-1 data."""
        errors = []
        warnings = []
        
        # Ownership percentage should be 0-100
        if not (Decimal("0") <= k1.ownership_percentage <= Decimal("100")):
            errors.append(f"Invalid ownership percentage: {k1.ownership_percentage}%")
        
        # Entity type validation
        if k1.entity_type not in ("partnership", "s_corp"):
            errors.append(f"Invalid entity type: {k1.entity_type}")
        
        # S-corps shouldn't have guaranteed payments (Box 4)
        if k1.entity_type == "s_corp" and k1.guaranteed_payments != Decimal("0"):
            warnings.append(
                f"S-corp K-1 has guaranteed payments ({k1.guaranteed_payments}) - verify"
            )
        
        # K-1 with huge losses relative to income is suspicious
        if k1.total_k1_income < Decimal("-100000"):
            warnings.append(
                f"Large K-1 loss ({k1.total_k1_income}) - verify basis and at-risk"
            )
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
        )
    
    def validate_1099b(self, form: Form1099B) -> ValidationResult:
        """Validate 1099-B transaction data."""
        errors = []
        warnings = []
        
        # Proceeds must be positive
        if form.proceeds <= Decimal("0"):
            errors.append(f"Invalid proceeds: {form.proceeds}")
        
        # If cost basis reported to IRS, it should exist
        if form.basis_reported_to_irs and form.cost_basis is None:
            warnings.append("Basis reported to IRS but not extracted - verify document")
        
        # Can't be both short-term and long-term
        if form.is_short_term and form.is_long_term:
            errors.append("Transaction marked as both short-term and long-term")
        
        # Wash sale shouldn't exceed loss
        if form.cost_basis and form.proceeds < form.cost_basis:
            loss = form.cost_basis - form.proceeds
            if form.wash_sale_loss_disallowed > loss:
                errors.append(
                    f"Wash sale disallowed ({form.wash_sale_loss_disallowed}) "
                    f"exceeds loss ({loss})"
                )
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
        )
    
    def validate_cross_document(
        self,
        w2s: list[FormW2],
        k1s: list[FormK1],
        forms_1099: list,
    ) -> ValidationResult:
        """Cross-document consistency validation."""
        errors = []
        warnings = []
        
        # All documents should have same recipient TIN (last 4 digits)
        tins = set()
        for w2 in w2s:
            tins.add(w2.employee_tin[-4:])
        for k1 in k1s:
            tins.add(k1.recipient_tin[-4:])
        for f in forms_1099:
            if hasattr(f, 'recipient_tin'):
                tins.add(f.recipient_tin[-4:])
        
        if len(tins) > 1:
            warnings.append(
                f"Multiple TIN last-4 found across documents: {tins}. "
                "Verify all documents are for the same taxpayer."
            )
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
        )
```

**Verify:**
```bash
uv run python -c "
from decimal import Decimal
from src.documents.validation import DocumentValidator, ValidationResult
from src.documents.models import FormK1

validator = DocumentValidator()
k1 = FormK1(
    entity_name='Test Partnership',
    entity_ein='12-3456789',
    entity_type='s_corp',  # S-corp
    tax_year=2024,
    recipient_name='Test',
    recipient_tin='123-45-6789',
    ownership_percentage=Decimal('25'),
    guaranteed_payments=Decimal('50000'),  # Should warn - S-corps don't have GP
)
result = validator.validate_k1(k1)
print(f'Valid: {result.is_valid}')
print(f'Warnings: {result.warnings}')
"
```

**Done:** Document validation layer for extraction error detection

---

## Success Criteria

- [ ] FORM_K1_PROMPT with all box mappings including capital account
- [ ] FORM_1099_B_PROMPT for multi-transaction forms
- [ ] FORM_1099_B_SUMMARY_PROMPT for high-volume statements
- [ ] extract_k1() returns FormK1 model with basis fields
- [ ] extract_1099_b() returns list of Form1099B
- [ ] extract_1099_b_smart() uses summary mode for 50+ transactions
- [ ] Mock functions return realistic test data
- [ ] extract_document() router updated
- [ ] DocumentValidator validates W-2, K-1, 1099-B
- [ ] Cross-document validation catches TIN mismatches
- [ ] All extractor tests pass
- [ ] All Phase 3 tests still pass

## Commit

After all tasks complete:
```bash
git add -A
git commit -m "feat(04-02): add K-1 and 1099-B extractors with prompts"
```
