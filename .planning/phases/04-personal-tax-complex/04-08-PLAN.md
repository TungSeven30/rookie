# Plan 04-08: Complex Return Agent Integration

---
phase: 04-personal-tax-complex
plan: 08
type: execute
wave: 5
depends_on: ["04-03", "04-04", "04-05", "04-06", "04-07"]
---

## Objective

Update PersonalTaxAgent to orchestrate complex returns with all Phase 4 schedules and forms.

**Purpose:** Integrate all new document types, calculators, and deductions into a unified agent that handles complex personal tax returns.

**Output:**
- Updated PersonalTaxAgent.process()
- New schedule sheets in Drake worksheet
- Updated preparer notes for complex items
- Escalation rules for complex scenarios
- Integration tests with complex returns

## API Compatibility Note

**CRITICAL:** This plan assumes API changes from Phase 4 plans:
- `aggregate_income()` signature extended with `schedule_c_data`, `forms_k1`, `filing_status`
- `calculate_tax_liability()` renamed/extended to accept `qbi_components`
- `IncomeSummary` extended with Schedule C/E/D and SE fields

If existing Phase 3 code uses different APIs (e.g., `calculate_tax()`, different `aggregate_income` signature), 
a compatibility refactor task is included (Task 0).

## Data Sourcing for Complex Schedules

**Schedule C Expenses:**
- Current scope: 1099-NEC provides gross receipts only
- Expenses must come from: client questionnaire, CSV upload, or prior year data
- For v1: If no expense data available, Schedule C = gross receipts only, flag for CPA review
- Future: Bookkeeping agent (Phase 7) can provide categorized expenses

**Schedule E Rental Data:**
- K-1 Box 2 (net_rental_real_estate) provides K-1 rental income
- Direct rental properties require: property addresses, income, expenses
- For v1: Only K-1 rental income supported; direct rentals escalated for manual entry
- Future: Rental questionnaire or bank statement categorization

**Composite 1099 Statements:**
- Brokerage year-end statements often combine 1099-DIV, 1099-INT, 1099-B
- Classifier should identify "composite" documents and extract each section
- For v1: Add escalation if classifier confidence is LOW on composite documents

## Tasks

### Task 0: API Compatibility Refactor (Prerequisite)

**Files:** src/agents/personal_tax/calculator.py, src/agents/personal_tax/agent.py

**Action:**
Ensure Phase 3 APIs are compatible with Phase 4 extensions:

1. Verify `aggregate_income()` accepts new optional parameters:
   - `schedule_c_data: list[ScheduleCData] | None = None`
   - `forms_k1: list[FormK1] | None = None`
   - `filing_status: FilingStatus = FilingStatus.SINGLE`

2. Verify `IncomeSummary` dataclass has all required fields (add if missing):
   - `schedule_c_profit`, `k1_ordinary_income`, `k1_guaranteed_payments`
   - `self_employment_income`, `se_tax`, `se_tax_deduction`
   - `schedule_e_rental_income`, `schedule_e_expenses`, `schedule_e_net`
   - `capital_gains_short_term`, `capital_gains_long_term`, `capital_gains_net`

3. Create `calculate_tax_liability()` wrapper if Phase 3 uses `calculate_tax()`:
   - Accept new `qbi_components` parameter
   - Return `TaxSituation` with `qbi_deduction` field

4. Update any existing tests that break due to signature changes

**Verify:**
```bash
uv run pytest tests/agents/personal_tax/test_calculator.py -v --tb=short
```
All Phase 3 calculator tests still pass.

**Done:** API compatibility verified and refactored if needed

### Task 1: Update Document Classification

**Files:** src/agents/personal_tax/agent.py

**Action:**
Extend document classification to handle new types:

```python
COMPLEX_DOCUMENT_TYPES = {
    DocumentType.FORM_K1,
    DocumentType.FORM_1099_B,
    DocumentType.FORM_1095_A,
}

async def _classify_documents(
    self,
    documents: list[UploadedDocument],
) -> dict[DocumentType, list[UploadedDocument]]:
    """
    Classify documents by type.
    
    Returns dict mapping document type to list of documents.
    Handles both simple and complex document types.
    """
    classified: dict[DocumentType, list[UploadedDocument]] = {}
    
    for doc in documents:
        doc_type = await classify_document(
            self.client,
            doc.image_data,
            mock=self.mock_mode,
        )
        
        if doc_type not in classified:
            classified[doc_type] = []
        classified[doc_type].append(doc)
        
        # Track complexity level
        if doc_type in COMPLEX_DOCUMENT_TYPES:
            self.return_complexity = "complex"
    
    return classified
```

**Done:** Document classification handles complex types

---

### Task 2: Update Document Extraction

**Files:** src/agents/personal_tax/agent.py

**Action:**
Extend extraction to handle K-1, 1099-B, 1095-A:

```python
async def _extract_all_documents(
    self,
    classified: dict[DocumentType, list[UploadedDocument]],
) -> ExtractedDocuments:
    """
    Extract data from all classified documents.
    """
    extracted = ExtractedDocuments()
    
    # ... existing W-2, 1099 extraction ...
    
    # K-1 extraction
    if DocumentType.FORM_K1 in classified:
        for doc in classified[DocumentType.FORM_K1]:
            k1 = await extract_k1(
                self.client,
                doc.image_data,
                mock=self.mock_mode,
            )
            extracted.k1_forms.append(k1)
    
    # 1099-B extraction (returns list per form)
    if DocumentType.FORM_1099_B in classified:
        for doc in classified[DocumentType.FORM_1099_B]:
            transactions = await extract_1099_b(
                self.client,
                doc.image_data,
                mock=self.mock_mode,
            )
            extracted.transactions_1099b.extend(transactions)
    
    # 1095-A extraction
    if DocumentType.FORM_1095_A in classified:
        for doc in classified[DocumentType.FORM_1095_A]:
            form = await extract_1095_a(
                self.client,
                doc.image_data,
                mock=self.mock_mode,
            )
            extracted.forms_1095a.append(form)
    
    return extracted
```

Create ExtractedDocuments dataclass:

```python
@dataclass
class ExtractedDocuments:
    """Container for all extracted document data."""
    
    # Simple returns
    w2_forms: list[FormW2] = field(default_factory=list)
    forms_1099_int: list[Form1099INT] = field(default_factory=list)
    forms_1099_div: list[Form1099DIV] = field(default_factory=list)
    forms_1099_misc: list[Form1099MISC] = field(default_factory=list)
    forms_1099_nec: list[Form1099NEC] = field(default_factory=list)
    
    # Complex returns
    k1_forms: list[FormK1] = field(default_factory=list)
    transactions_1099b: list[Form1099B] = field(default_factory=list)
    forms_1095a: list[Form1095A] = field(default_factory=list)
```

**Done:** Extraction handles all Phase 4 document types

---

### Task 3: Implement Schedule Building

**Files:** src/agents/personal_tax/agent.py

**Action:**
Create schedule builders from extracted data:

```python
async def _build_schedules(
    self,
    extracted: ExtractedDocuments,
    client_info: ClientInfo,
) -> BuiltSchedules:
    """
    Build tax schedules from extracted documents.
    """
    schedules = BuiltSchedules()
    
    # Schedule C (from 1099-NEC + expense data)
    if extracted.forms_1099_nec:
        schedules.schedule_c = self._build_schedule_c(
            extracted.forms_1099_nec,
            client_info,
        )
    
    # Schedule D (from 1099-B transactions)
    # NOTE: convert_1099b_to_transactions returns (transactions, missing_basis_list)
    if extracted.transactions_1099b:
        transactions, missing_basis = convert_1099b_to_transactions(
            extracted.transactions_1099b
        )
        schedules.schedule_d = ScheduleDData(transactions=transactions)
        schedules.missing_basis_1099b = missing_basis  # For escalation context
    
    # Schedule E (from K-1 Box 2 rental income)
    # NOTE: v1 only supports K-1 rental income, not direct rental properties
    if extracted.k1_forms:
        schedules.schedule_e = self._build_schedule_e_from_k1s(extracted.k1_forms)
        schedules.k1_summary = self._summarize_k1s(extracted.k1_forms)
    
    # Premium Tax Credit data
    if extracted.forms_1095a:
        schedules.ptc_data = extracted.forms_1095a[0]  # Primary form
    
    return schedules


def _build_schedule_e_from_k1s(self, k1_forms: list[FormK1]) -> ScheduleEData | None:
    """
    Build Schedule E data from K-1 Box 2 (net rental real estate income).
    
    NOTE: v1 limitation - only K-1 rental income is supported.
    Direct rental properties require manual data entry.
    """
    rental_k1s = [k1 for k1 in k1_forms if k1.net_rental_real_estate != Decimal("0")]
    
    if not rental_k1s:
        return None
    
    # Create a "virtual" rental property for each K-1 with rental income
    properties = []
    for k1 in rental_k1s:
        # K-1 Box 2 is already net income (after expenses at entity level)
        prop = RentalProperty(
            property_address=f"K-1: {k1.entity_name}",
            property_type="K-1 Pass-through",
            fair_rental_days=365,  # Assumed full year
            rental_income=max(Decimal("0"), k1.net_rental_real_estate),
            expenses=RentalExpenses(),  # No expenses - K-1 is already net
            qbi_eligible=True,  # K-1 rental qualifies for QBI
        )
        # If K-1 Box 2 is negative, it's a loss
        if k1.net_rental_real_estate < Decimal("0"):
            prop.rental_income = Decimal("0")
            prop.expenses = RentalExpenses(other_expenses=abs(k1.net_rental_real_estate))
        properties.append(prop)
    
    return ScheduleEData(
        properties=properties,
        actively_participates=True,  # Default assumption for K-1
        is_real_estate_professional=False,  # Would need client input
    )


@dataclass
class BuiltSchedules:
    """Container for built schedule data."""
    schedule_c: ScheduleCData | None = None
    schedule_d: ScheduleDData | None = None
    schedule_e: ScheduleEData | None = None
    k1_summary: K1Summary | None = None
    ptc_data: Form1095A | None = None
    missing_basis_1099b: list[Form1099B] = field(default_factory=list)  # For escalation
```

**Done:** Schedule builders from extracted data

---

### Task 4: Update Tax Calculation Flow

**Files:** src/agents/personal_tax/agent.py

**Action:**
Integrate complex calculations into process():

```python
async def process(
    self,
    documents: list[UploadedDocument],
    client_info: ClientInfo,
    prior_year_data: PriorYearData | None = None,
) -> PersonalTaxResult:
    """
    Process personal tax return with all schedules.
    """
    # Classify and extract documents
    classified = await self._classify_documents(documents)
    extracted = await self._extract_all_documents(classified)
    
    # Build schedules
    schedules = await self._build_schedules(extracted, client_info)
    
    # Calculate Schedule C and SE tax
    se_tax_result = None
    if schedules.schedule_c:
        sch_c_result = calculate_schedule_c(schedules.schedule_c)
        se_tax_result = calculate_self_employment_tax(
            sch_c_result["net_profit_or_loss"],
            client_info.filing_status,
        )
    
    # Calculate Schedule E
    schedule_e_result = None
    if schedules.schedule_e:
        # Need preliminary MAGI for passive loss calculation
        preliminary_agi = self._estimate_agi(extracted, schedules)
        schedule_e_result = calculate_schedule_e(
            schedules.schedule_e,
            preliminary_agi,
            client_info.filing_status,
        )
    
    # Calculate Schedule D
    schedule_d_result = None
    if schedules.schedule_d:
        schedule_d_result = calculate_schedule_d(
            schedules.schedule_d,
            client_info.filing_status,
        )
    
    # Aggregate income
    income = aggregate_income(
        forms_w2=extracted.w2_forms,
        forms_1099_int=extracted.forms_1099_int,
        forms_1099_div=extracted.forms_1099_div,
        forms_1099_misc=extracted.forms_1099_misc,
        forms_1099_nec=extracted.forms_1099_nec,
        schedule_c_data=[schedules.schedule_c] if schedules.schedule_c else None,
        forms_k1=extracted.k1_forms,
        schedule_e_data=schedules.schedule_e,  # Pass Schedule E data
        filing_status=client_info.filing_status,
    )
    
    # Update IncomeSummary with Schedule E results
    if schedule_e_result:
        income.schedule_e_rental_income = schedule_e_result.total_rental_income
        income.schedule_e_expenses = schedule_e_result.total_expenses
        income.schedule_e_net = schedule_e_result.net_rental_income_loss
        income.schedule_e_suspended_loss = schedule_e_result.suspended_loss
    
    # Update IncomeSummary with Schedule D results
    if schedule_d_result:
        income.capital_gains_short_term = schedule_d_result.net_short_term_gain_loss
        income.capital_gains_long_term = schedule_d_result.net_long_term_gain_loss
        income.capital_gains_net = schedule_d_result.net_included_in_income
        income.capital_loss_carryforward = schedule_d_result.new_loss_carryforward
    
    # Build QBI components
    qbi_components = self._build_qbi_components(
        schedules,
        extracted.k1_forms,
        se_tax_result,
    )
    
    # Calculate tax with QBI
    tax_situation = calculate_tax_liability(
        income=income,
        filing_status=client_info.filing_status,
        qbi_components=qbi_components,
    )
    
    # Calculate Premium Tax Credit if applicable
    ptc_result = None
    if schedules.ptc_data:
        ptc_result = calculate_premium_tax_credit(
            household_income=tax_situation.agi,
            household_size=client_info.household_size,
            form_1095a=schedules.ptc_data,
            filing_status=client_info.filing_status,
        )
    
    # Generate outputs
    result = await self._generate_outputs(
        extracted=extracted,
        schedules=schedules,
        income=income,
        tax_situation=tax_situation,
        se_tax=se_tax_result,
        schedule_e=schedule_e_result,
        schedule_d=schedule_d_result,
        ptc=ptc_result,
        prior_year=prior_year_data,
    )
    
    return result
```

**Done:** Tax calculation integrates all Phase 4 schedules

---

### Task 4b: Add Estimated Tax Payment Tracking

**Files:** src/agents/personal_tax/payments.py (new)

**Action:**
Create estimated payment tracking for accurate balance due/refund:

```python
"""Estimated tax payment tracking."""

from dataclasses import dataclass, field
from decimal import Decimal


@dataclass
class EstimatedPayments:
    """Estimated tax payments made during the year."""
    
    tax_year: int
    
    # Federal estimated payments (Form 1040-ES)
    q1_federal: Decimal = Decimal("0")  # Due April 15
    q2_federal: Decimal = Decimal("0")  # Due June 15
    q3_federal: Decimal = Decimal("0")  # Due September 15
    q4_federal: Decimal = Decimal("0")  # Due January 15 (next year)
    
    # Extension payment
    extension_payment: Decimal = Decimal("0")
    
    # Prior year overpayment applied
    prior_year_refund_applied: Decimal = Decimal("0")
    
    # Additional payments
    additional_payments: list[tuple[str, Decimal]] = field(default_factory=list)
    
    @property
    def total_federal_estimated(self) -> Decimal:
        """Total federal estimated payments."""
        base = self.q1_federal + self.q2_federal + self.q3_federal + self.q4_federal
        additional = sum(amt for _, amt in self.additional_payments)
        return base + self.extension_payment + self.prior_year_refund_applied + additional
    
    # State estimated payments (for state return support)
    state_payments: dict[str, Decimal] = field(default_factory=dict)


@dataclass
class TaxSummary:
    """Final tax summary with payments and balance due."""
    
    # Computed amounts
    total_tax_liability: Decimal
    total_credits: Decimal
    
    # Withholding
    federal_withholding: Decimal  # From W-2s
    
    # Estimated payments
    estimated_payments: EstimatedPayments
    
    # Premium Tax Credit impact
    ptc_adjustment: Decimal = Decimal("0")  # + = additional credit, - = repayment
    
    @property
    def total_payments(self) -> Decimal:
        """Total payments and credits toward tax liability."""
        return (
            self.federal_withholding +
            self.estimated_payments.total_federal_estimated +
            self.total_credits +
            max(Decimal("0"), self.ptc_adjustment)
        )
    
    @property
    def balance_due_or_refund(self) -> Decimal:
        """
        Positive = refund due to taxpayer
        Negative = balance due from taxpayer
        """
        ptc_repayment = abs(min(Decimal("0"), self.ptc_adjustment))
        return self.total_payments - self.total_tax_liability - ptc_repayment
    
    @property
    def is_refund(self) -> bool:
        """True if taxpayer is getting a refund."""
        return self.balance_due_or_refund > Decimal("0")
```

**Verify:**
```bash
uv run python -c "
from decimal import Decimal
from src.agents.personal_tax.payments import EstimatedPayments, TaxSummary

payments = EstimatedPayments(
    tax_year=2024,
    q1_federal=Decimal('5000'),
    q2_federal=Decimal('5000'),
    q3_federal=Decimal('5000'),
    q4_federal=Decimal('5000'),
)
summary = TaxSummary(
    total_tax_liability=Decimal('35000'),
    total_credits=Decimal('2000'),
    federal_withholding=Decimal('15000'),
    estimated_payments=payments,
)
print(f'Total payments: {summary.total_payments}')
print(f'Balance: {summary.balance_due_or_refund}')
print(f'Is refund: {summary.is_refund}')
"
```

**Done:** Estimated tax payment tracking with balance due/refund calculation

---

### Task 5: Update Drake Worksheet Generator

**Files:** src/agents/personal_tax/output.py

**Action:**
Add new schedule sheets to Drake worksheet:

```python
def generate_drake_worksheet(
    income: IncomeSummary,
    tax_situation: TaxSituation,
    # New parameters
    schedule_c: ScheduleCData | None = None,
    schedule_e: ScheduleEResult | None = None,
    schedule_d: ScheduleDResult | None = None,
    qbi_deduction: QBIDeduction | None = None,
    ptc: PremiumTaxCredit | None = None,
) -> bytes:
    """
    Generate Drake-compatible Excel worksheet with all schedules.
    """
    wb = Workbook()
    
    # ... existing sheets ...
    
    # Schedule C sheet
    if schedule_c:
        ws_c = wb.create_sheet("Schedule C")
        _populate_schedule_c_sheet(ws_c, schedule_c)
    
    # Schedule E sheet
    if schedule_e:
        ws_e = wb.create_sheet("Schedule E")
        _populate_schedule_e_sheet(ws_e, schedule_e)
    
    # Schedule D sheet
    if schedule_d:
        ws_d = wb.create_sheet("Schedule D")
        _populate_schedule_d_sheet(ws_d, schedule_d)
    
    # QBI sheet
    if qbi_deduction:
        ws_qbi = wb.create_sheet("QBI Deduction")
        _populate_qbi_sheet(ws_qbi, qbi_deduction)
    
    # Form 8962 sheet
    if ptc:
        ws_ptc = wb.create_sheet("Form 8962")
        _populate_form_8962_sheet(ws_ptc, ptc)
    
    # Form 8949 sheets (required for Schedule D with adjustments)
    if schedule_d and schedule_d.transactions:
        _generate_form_8949_sheets(wb, schedule_d.transactions, schedule_d)
    
    # Save to bytes
    output = BytesIO()
    wb.save(output)
    return output.getvalue()


def _generate_form_8949_sheets(
    wb: Workbook,
    transactions: list[CapitalTransaction],
    schedule_d_result: ScheduleDResult,
) -> None:
    """
    Generate Form 8949 sheets for Schedule D transactions.
    
    Creates separate sheets for each 8949 category:
    - Part I (Short-Term): Box A (basis reported), Box B (basis not reported)
    - Part II (Long-Term): Box D (basis reported), Box E (basis not reported)
    """
    # Categorize transactions
    categories = {
        "8949_Part_I_A": [],  # Short-term, basis reported
        "8949_Part_I_B": [],  # Short-term, basis NOT reported
        "8949_Part_II_D": [],  # Long-term, basis reported
        "8949_Part_II_E": [],  # Long-term, basis NOT reported
    }
    
    for txn in transactions:
        if txn.is_short_term:
            if txn.basis_reported_to_irs:
                categories["8949_Part_I_A"].append(txn)
            else:
                categories["8949_Part_I_B"].append(txn)
        elif txn.is_long_term:
            if txn.basis_reported_to_irs:
                categories["8949_Part_II_D"].append(txn)
            else:
                categories["8949_Part_II_E"].append(txn)
    
    # Create sheets only for non-empty categories
    for category_name, txns in categories.items():
        if not txns:
            continue
        
        ws = wb.create_sheet(category_name)
        _populate_8949_sheet(ws, txns, category_name)


def _populate_8949_sheet(
    ws: Worksheet,
    transactions: list[CapitalTransaction],
    category: str,
) -> None:
    """Populate a single Form 8949 sheet."""
    # Header row matching IRS Form 8949
    headers = [
        "(a) Description",
        "(b) Date acquired",
        "(c) Date sold",
        "(d) Proceeds",
        "(e) Cost basis",
        "(f) Code(s)",  # W for wash sale, B for basis adjustment, etc.
        "(g) Adjustment",
        "(h) Gain or loss",
    ]
    
    for col, header in enumerate(headers, 1):
        ws.cell(row=1, column=col, value=header)
    
    # Transaction rows
    for row_num, txn in enumerate(transactions, 2):
        ws.cell(row=row_num, column=1, value=txn.description)
        ws.cell(row=row_num, column=2, value=txn.date_acquired or "Various")
        ws.cell(row=row_num, column=3, value=txn.date_sold)
        ws.cell(row=row_num, column=4, value=float(txn.proceeds))
        ws.cell(row=row_num, column=5, value=float(txn.cost_basis) if txn.cost_basis else "")
        
        # Adjustment codes
        codes = []
        if txn.wash_sale_disallowed > Decimal("0"):
            codes.append("W")
        ws.cell(row=row_num, column=6, value=",".join(codes))
        
        # Adjustment amount
        adjustment = txn.wash_sale_disallowed
        ws.cell(row=row_num, column=7, value=float(adjustment) if adjustment else "")
        
        # Gain/loss
        if txn.gain_loss is not None:
            ws.cell(row=row_num, column=8, value=float(txn.gain_loss))
    
    # Category totals row
    total_row = len(transactions) + 2
    ws.cell(row=total_row, column=1, value="TOTALS")
    ws.cell(row=total_row, column=4, value=f"=SUM(D2:D{total_row-1})")
    ws.cell(row=total_row, column=5, value=f"=SUM(E2:E{total_row-1})")
    ws.cell(row=total_row, column=7, value=f"=SUM(G2:G{total_row-1})")
    ws.cell(row=total_row, column=8, value=f"=SUM(H2:H{total_row-1})")


def _populate_schedule_c_sheet(ws: Worksheet, data: ScheduleCData) -> None:
    """Populate Schedule C worksheet."""
    ws["A1"] = "Schedule C - Profit or Loss from Business"
    ws["A3"] = "Business Name"
    ws["B3"] = data.business_name
    ws["A4"] = "Principal Business Code"
    ws["B4"] = data.principal_business_code
    
    # Income section
    ws["A6"] = "INCOME"
    ws["A7"] = "Gross Receipts (Line 1)"
    ws["B7"] = float(data.gross_receipts)
    ws["A8"] = "Cost of Goods Sold (Line 4)"
    ws["B8"] = float(data.cost_of_goods_sold)
    ws["A9"] = "Gross Profit (Line 5)"
    ws["B9"] = float(data.gross_profit)
    
    # Expenses section
    ws["A11"] = "EXPENSES"
    row = 12
    for field, value in [
        ("Advertising", data.expenses.advertising),
        ("Car/Truck", data.expenses.car_truck),
        ("Depreciation", data.expenses.depreciation),
        ("Insurance", data.expenses.insurance),
        ("Interest", data.expenses.interest_mortgage + data.expenses.interest_other),
        ("Legal/Professional", data.expenses.legal_professional),
        ("Office Expense", data.expenses.office_expense),
        ("Rent", data.expenses.rent_other + data.expenses.rent_vehicles_machinery),
        ("Repairs", data.expenses.repairs_maintenance),
        ("Supplies", data.expenses.supplies),
        ("Taxes/Licenses", data.expenses.taxes_licenses),
        ("Travel", data.expenses.travel),
        ("Utilities", data.expenses.utilities),
        ("Wages", data.expenses.wages),
        ("Other", data.expenses.other_expenses),
    ]:
        ws[f"A{row}"] = field
        ws[f"B{row}"] = float(value)
        row += 1
    
    # Net profit
    ws[f"A{row + 1}"] = "Net Profit (Line 31)"
    ws[f"B{row + 1}"] = float(data.net_profit_or_loss)
```

**Done:** Drake worksheet includes new schedule sheets

---

### Task 6: Update Preparer Notes

**Files:** src/agents/personal_tax/output.py

**Action:**
Add complex item sections to preparer notes:

```python
def generate_preparer_notes(
    income: IncomeSummary,
    tax_situation: TaxSituation,
    variances: list[Variance],
    escalations: list[Escalation],
    # New parameters
    schedule_c: ScheduleCData | None = None,
    schedule_d: ScheduleDResult | None = None,
    qbi: QBIDeduction | None = None,
    ptc: PremiumTaxCredit | None = None,
) -> str:
    """
    Generate preparer notes with complex item sections.
    """
    notes = []
    notes.append("# Tax Return Preparer Notes")
    notes.append(f"Generated: {datetime.now().isoformat()}")
    notes.append("")
    
    # ... existing sections ...
    
    # Schedule C section
    if schedule_c:
        notes.append("## Schedule C - Self-Employment")
        notes.append(f"- Business: {schedule_c.business_name}")
        notes.append(f"- Gross Receipts: ${schedule_c.gross_receipts:,.2f}")
        notes.append(f"- Total Expenses: ${schedule_c.total_expenses:,.2f}")
        notes.append(f"- Net Profit/Loss: ${schedule_c.net_profit_or_loss:,.2f}")
        if income.se_tax > 0:
            notes.append(f"- Self-Employment Tax: ${income.se_tax:,.2f}")
            notes.append(f"- SE Tax Deduction (above-the-line): ${income.se_tax_deduction:,.2f}")
        notes.append("")
    
    # Schedule D section
    if schedule_d:
        notes.append("## Schedule D - Capital Gains/Losses")
        notes.append(f"- Short-Term Net: ${schedule_d.net_short_term_gain_loss:,.2f}")
        notes.append(f"- Long-Term Net: ${schedule_d.net_long_term_gain_loss:,.2f}")
        notes.append(f"- Net Capital Gain/Loss: ${schedule_d.net_included_in_income:,.2f}")
        if schedule_d.capital_loss_limitation_applied:
            notes.append(f"- **Loss Limited to $3,000**")
            notes.append(f"- Carryforward to Next Year: ${schedule_d.new_loss_carryforward:,.2f}")
        notes.append("")
    
    # QBI section
    if qbi and qbi.final_qbi_deduction > 0:
        notes.append("## QBI Deduction (Section 199A)")
        notes.append(f"- Total QBI: ${qbi.total_qbi:,.2f}")
        notes.append(f"- QBI Deduction: ${qbi.final_qbi_deduction:,.2f}")
        if qbi.wage_limit_applied:
            notes.append("- **W-2 wage limitation applied**")
        if qbi.sstb_exclusion_applied:
            notes.append("- **SSTB exclusion applied**")
        notes.append("")
    
    # PTC section
    if ptc:
        notes.append("## Form 8962 - Premium Tax Credit")
        notes.append(f"- Household Income: ${ptc.household_income:,.2f}")
        notes.append(f"- FPL Percentage: {ptc.income_as_fpl_percent:.1f}%")
        notes.append(f"- Calculated PTC: ${ptc.calculated_ptc:,.2f}")
        notes.append(f"- Advance Payments Received: ${ptc.advance_ptc_received:,.2f}")
        if ptc.repayment_required:
            notes.append(f"- **Repayment Required: ${ptc.repayment_amount:,.2f}**")
            if ptc.repayment_limitation:
                notes.append(f"- Repayment limited to ${ptc.repayment_limitation:,.2f}")
        else:
            notes.append(f"- Additional Credit: ${ptc.additional_credit:,.2f}")
        notes.append("")
    
    return "\n".join(notes)
```

**Done:** Preparer notes include complex item sections

---

### Task 7: Add Escalation Rules

**Files:** src/agents/personal_tax/agent.py

**Action:**
Add escalation rules for complex scenarios:

```python
COMPLEX_ESCALATION_RULES = [
    # K-1 escalations
    EscalationRule(
        id="k1_low_confidence",
        condition=lambda ctx: any(
            k1.confidence == ConfidenceLevel.LOW
            for k1 in ctx.k1_forms
        ),
        message="K-1 extraction has low confidence - manual review required",
        severity=EscalationSeverity.HIGH,
    ),
    EscalationRule(
        id="k1_foreign_transactions",
        condition=lambda ctx: any(
            k1.foreign_transactions > Decimal("0")  # Box 16 field added in 04-01
            for k1 in ctx.k1_forms
        ),
        message="K-1 contains foreign transactions (Box 16) - may require Form 8865/8938",
        severity=EscalationSeverity.MEDIUM,
    ),
    
    # Schedule C escalations
    EscalationRule(
        id="schedule_c_no_expenses",
        condition=lambda ctx: ctx.schedule_c and ctx.schedule_c.expenses.total == Decimal("0"),
        message="Schedule C has no expenses - verify expense data was provided",
        severity=EscalationSeverity.MEDIUM,
    ),
    EscalationRule(
        id="schedule_c_loss",
        condition=lambda ctx: ctx.schedule_c and ctx.schedule_c.net_profit_or_loss < Decimal("-50000"),
        message="Large Schedule C loss - verify documentation and hobby loss rules",
        severity=EscalationSeverity.MEDIUM,
    ),
    EscalationRule(
        id="schedule_c_high_expenses",
        condition=lambda ctx: ctx.schedule_c and ctx.schedule_c.gross_receipts > 0 and 
            ctx.schedule_c.expenses.total > ctx.schedule_c.gross_receipts * Decimal("0.9"),
        message="Expenses exceed 90% of gross receipts - verify business purpose",
        severity=EscalationSeverity.LOW,
    ),
    
    # Schedule D escalations
    EscalationRule(
        id="wash_sale",
        condition=lambda ctx: ctx.schedule_d_result and any(
            t.wash_sale_disallowed > Decimal("0")
            for t in ctx.schedule_d.transactions
        ),
        message="Wash sale transactions present - verify basis adjustments",
        severity=EscalationSeverity.MEDIUM,
    ),
    EscalationRule(
        id="missing_cost_basis",
        condition=lambda ctx: ctx.schedule_d_result and 
            ctx.schedule_d_result.transactions_missing_basis > 0,
        message=lambda ctx: f"{ctx.schedule_d_result.transactions_missing_basis} transactions missing cost basis - needs client documentation",
        severity=EscalationSeverity.HIGH,
    ),
    
    # QBI escalations
    EscalationRule(
        id="qbi_sstb_phaseout",
        condition=lambda ctx: ctx.qbi and ctx.qbi.is_above_threshold and ctx.qbi.sstb_exclusion_applied,
        message="SSTB income in phaseout range - verify QBI treatment",
        severity=EscalationSeverity.MEDIUM,
    ),
    
    # PTC escalations
    EscalationRule(
        id="ptc_large_repayment",
        condition=lambda ctx: ctx.ptc and ctx.ptc.repayment_amount > Decimal("2000"),
        message="Large PTC repayment required - verify income changes during year",
        severity=EscalationSeverity.MEDIUM,
    ),
    EscalationRule(
        id="ptc_partial_year",
        condition=lambda ctx: ctx.ptc and ctx.ptc.is_partial_year,
        message="Partial-year marketplace coverage detected - verify Form 8962 calculation",
        severity=EscalationSeverity.LOW,
    ),
    
    # Composite 1099 / Classification escalations
    EscalationRule(
        id="composite_1099_low_confidence",
        condition=lambda ctx: any(
            doc.classification_confidence == ConfidenceLevel.LOW and 
            "composite" in doc.classification_notes.lower()
            for doc in ctx.classified_documents
        ),
        message="Composite brokerage statement may have missed some forms - manual review",
        severity=EscalationSeverity.MEDIUM,
    ),
    
    # Direct rental escalation (Schedule E without K-1 source)
    EscalationRule(
        id="direct_rental_not_supported",
        condition=lambda ctx: ctx.has_direct_rental_indicators and not ctx.schedule_e,
        message="Direct rental property income detected but no rental data provided - manual entry required",
        severity=EscalationSeverity.HIGH,
    ),
]
```

**Done:** Escalation rules for complex scenarios

---

### Task 8: Create Integration Tests

**Files:** tests/agents/personal_tax/test_agent_integration.py

**Action:**
Create comprehensive integration tests:

```python
class TestComplexReturnIntegration:
    """Integration tests for complex return processing."""
    
    @pytest.mark.asyncio
    async def test_schedule_c_return(self):
        """Process return with Schedule C self-employment."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        documents = [
            create_mock_document(DocumentType.FORM_W2),
            create_mock_document(DocumentType.FORM_1099_NEC),
        ]
        client = ClientInfo(
            name="Self Employed",
            filing_status=FilingStatus.SINGLE,
        )
        
        result = await agent.process(documents, client)
        
        assert result.income.self_employment_income > 0
        assert result.income.se_tax > 0
        assert result.tax_situation.qbi_deduction > 0
    
    @pytest.mark.asyncio
    async def test_schedule_d_return(self):
        """Process return with capital gains."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        documents = [
            create_mock_document(DocumentType.FORM_W2),
            create_mock_document(DocumentType.FORM_1099_B),
        ]
        client = ClientInfo(
            name="Investor",
            filing_status=FilingStatus.SINGLE,
        )
        
        result = await agent.process(documents, client)
        
        assert result.income.capital_gains_net != 0
    
    @pytest.mark.asyncio
    async def test_k1_return(self):
        """Process return with K-1 partnership income."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        documents = [
            create_mock_document(DocumentType.FORM_K1),
        ]
        client = ClientInfo(
            name="Partner",
            filing_status=FilingStatus.MARRIED_FILING_JOINTLY,
        )
        
        result = await agent.process(documents, client)
        
        assert result.income.k1_ordinary_income > 0
    
    @pytest.mark.asyncio
    async def test_aca_marketplace_return(self):
        """Process return with Form 1095-A and PTC."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        documents = [
            create_mock_document(DocumentType.FORM_W2),
            create_mock_document(DocumentType.FORM_1095_A),
        ]
        client = ClientInfo(
            name="Marketplace Enrollee",
            filing_status=FilingStatus.SINGLE,
            household_size=2,
        )
        
        result = await agent.process(documents, client)
        
        assert result.ptc is not None
        assert result.ptc.is_eligible
    
    @pytest.mark.asyncio
    async def test_complex_return_all_schedules(self):
        """Process return with all complex schedules."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        documents = [
            create_mock_document(DocumentType.FORM_W2),
            create_mock_document(DocumentType.FORM_1099_NEC),
            create_mock_document(DocumentType.FORM_K1),
            create_mock_document(DocumentType.FORM_1099_B),
            create_mock_document(DocumentType.FORM_1095_A),
        ]
        client = ClientInfo(
            name="Complex Filer",
            filing_status=FilingStatus.MARRIED_FILING_JOINTLY,
            household_size=4,
        )
        prior_year = PriorYearData(
            agi=Decimal("150000"),
            federal_tax=Decimal("25000"),
        )
        
        result = await agent.process(documents, client, prior_year)
        
        # Verify all schedules processed
        assert result.income.wages > 0
        assert result.income.self_employment_income > 0
        assert result.income.k1_ordinary_income > 0
        assert result.income.capital_gains_net != 0
        assert result.ptc is not None
        assert result.tax_situation.qbi_deduction >= 0
        
        # Verify outputs generated
        assert result.drake_worksheet is not None
        assert len(result.drake_worksheet) > 0
        assert "Schedule C" in result.preparer_notes
        assert "Schedule D" in result.preparer_notes
    
    @pytest.mark.asyncio
    async def test_escalations_generated(self):
        """Complex returns generate appropriate escalations."""
        agent = PersonalTaxAgent(mock_mode=True)
        
        # Mock data that triggers escalations
        documents = [
            create_mock_document(DocumentType.FORM_1099_B),  # Wash sale
        ]
        client = ClientInfo(
            name="Complex Filer",
            filing_status=FilingStatus.SINGLE,
        )
        
        result = await agent.process(documents, client)
        
        # Should have escalations
        assert len(result.escalations) >= 0  # May have wash sale escalation
```

**Verify:**
```bash
uv run pytest tests/agents/personal_tax/test_agent_integration.py -v --tb=short
```
All integration tests pass.

**Done:** 10+ integration tests for complex returns pass

---

## Success Criteria

- [ ] API compatibility verified (Task 0)
- [ ] Document classification handles K-1, 1099-B, 1095-A
- [ ] Extraction for all new document types works
- [ ] Form1099BSummary for high-volume (50+) broker statements
- [ ] DocumentValidator catches extraction errors
- [ ] Schedule C/SE tax calculated and integrated
- [ ] K-1 SE tax uses Box 14 only (not Box 1 + Box 4)
- [ ] S-corp K-1s excluded from SE tax
- [ ] K-1 basis fields track capital account (requires_basis_escalation)
- [ ] Schedule E with passive loss limitations
- [ ] Schedule E built from K-1 Box 2 for v1
- [ ] Schedule D with capital loss limitations
- [ ] Missing cost basis escalates (not converted to zero)
- [ ] Prior year carryovers loaded (TaxYearCarryovers)
- [ ] QBI deduction calculated and applied
- [ ] K-1 QBI excludes guaranteed payments
- [ ] SSTB auto-classification from NAICS codes
- [ ] Premium Tax Credit reconciliation works
- [ ] Partial-year PTC coverage flagged
- [ ] Estimated tax payments tracked (EstimatedPayments)
- [ ] Balance due/refund calculated correctly
- [ ] Drake worksheet includes all new schedules
- [ ] Form 8949 sheets generated for Schedule D
- [ ] Preparer notes include complex item sections
- [ ] Escalation rules trigger appropriately:
  - K-1 foreign transactions
  - K-1 basis limitation (significant loss, no basis info)
  - Missing cost basis
  - PTC partial-year
  - Composite 1099 low confidence
- [ ] All integration tests pass
- [ ] All Phase 3 tests still pass (317+)

## Commit

After all tasks complete:
```bash
git add -A
git commit -m "feat(04-08): integrate complex schedules into PersonalTaxAgent"
```

## Phase 4 Complete

After 04-08 is verified:

1. Run full test suite:
```bash
uv run pytest tests/ -v --tb=short
```

2. Update STATE.md:
```
Phase 4: COMPLETE
- Plans 04-01 through 04-08 executed
- All complex schedule calculators implemented
- PersonalTaxAgent handles complex returns
- Tests: 400+ passing
```

3. Commit state update:
```bash
git add .planning/STATE.md
git commit -m "chore: mark Phase 4 complete"
```
